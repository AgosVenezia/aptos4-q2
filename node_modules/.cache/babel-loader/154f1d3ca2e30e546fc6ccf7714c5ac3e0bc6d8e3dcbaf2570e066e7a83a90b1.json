{"ast":null,"code":"import { a } from \"./chunk-QQIVWB6G.mjs\";\nimport { a as i } from \"./chunk-6Q2O5G3J.mjs\";\nimport { bytesToHex as o, hexToBytes as l } from \"@noble/hashes/utils\";\nvar g = (s => (s.INCORRECT_NUMBER_OF_BYTES = \"incorrect_number_of_bytes\", s.INVALID_HEX_CHARS = \"invalid_hex_chars\", s.TOO_SHORT = \"too_short\", s.TOO_LONG = \"too_long\", s.LEADING_ZERO_X_REQUIRED = \"leading_zero_x_required\", s.LONG_FORM_REQUIRED_UNLESS_SPECIAL = \"long_form_required_unless_special\", s.INVALID_PADDING_ZEROES = \"INVALID_PADDING_ZEROES\", s))(g || {}),\n  r = class r extends a {\n    constructor(t) {\n      if (super(), t.length !== r.LENGTH) throw new i(\"AccountAddress data should be exactly 32 bytes long\", \"incorrect_number_of_bytes\");\n      this.data = t;\n    }\n    isSpecial() {\n      return this.data.slice(0, this.data.length - 1).every(t => t === 0) && this.data[this.data.length - 1] < 16;\n    }\n    toString() {\n      return `0x${this.toStringWithoutPrefix()}`;\n    }\n    toStringWithoutPrefix() {\n      let t = o(this.data);\n      return this.isSpecial() && (t = t[t.length - 1]), t;\n    }\n    toStringLong() {\n      return `0x${this.toStringLongWithoutPrefix()}`;\n    }\n    toStringLongWithoutPrefix() {\n      return o(this.data);\n    }\n    toUint8Array() {\n      return this.data;\n    }\n    serialize(t) {\n      t.serializeFixedBytes(this.data);\n    }\n    serializeForEntryFunction(t) {\n      let e = this.bcsToBytes();\n      t.serializeBytes(e);\n    }\n    serializeForScriptFunction(t) {\n      t.serializeU32AsUleb128(3), t.serialize(this);\n    }\n    static deserialize(t) {\n      let e = t.deserializeFixedBytes(r.LENGTH);\n      return new r(e);\n    }\n    static fromStringStrict(t) {\n      if (!t.startsWith(\"0x\")) throw new i(\"Hex string must start with a leading 0x.\", \"leading_zero_x_required\");\n      let e = r.fromString(t);\n      if (t.length !== r.LONG_STRING_LENGTH + 2) if (e.isSpecial()) {\n        if (t.length !== 3) throw new i(`The given hex string ${t} is a special address not in LONG form, it must be 0x0 to 0xf without padding zeroes.`, \"INVALID_PADDING_ZEROES\");\n      } else throw new i(`The given hex string ${t} is not a special address, it must be represented as 0x + 64 chars.`, \"long_form_required_unless_special\");\n      return e;\n    }\n    static fromString(t) {\n      let e = t;\n      if (t.startsWith(\"0x\") && (e = t.slice(2)), e.length === 0) throw new i(\"Hex string is too short, must be 1 to 64 chars long, excluding the leading 0x.\", \"too_short\");\n      if (e.length > 64) throw new i(\"Hex string is too long, must be 1 to 64 chars long, excluding the leading 0x.\", \"too_long\");\n      let n;\n      try {\n        n = l(e.padStart(64, \"0\"));\n      } catch (c) {\n        throw new i(`Hex characters are invalid: ${c?.message}`, \"invalid_hex_chars\");\n      }\n      return new r(n);\n    }\n    static from(t) {\n      return typeof t == \"string\" ? r.fromString(t) : t instanceof Uint8Array ? new r(t) : t;\n    }\n    static fromStrict(t) {\n      return typeof t == \"string\" ? r.fromStringStrict(t) : t instanceof Uint8Array ? new r(t) : t;\n    }\n    static isValid(t) {\n      try {\n        return t.strict ? r.fromStrict(t.input) : r.from(t.input), {\n          valid: !0\n        };\n      } catch (e) {\n        return {\n          valid: !1,\n          invalidReason: e?.invalidReason,\n          invalidReasonMessage: e?.message\n        };\n      }\n    }\n    equals(t) {\n      return this.data.length !== t.data.length ? !1 : this.data.every((e, n) => e === t.data[n]);\n    }\n  };\nr.LENGTH = 32, r.LONG_STRING_LENGTH = 64, r.ZERO = r.from(\"0x0\"), r.ONE = r.from(\"0x1\"), r.TWO = r.from(\"0x2\"), r.THREE = r.from(\"0x3\"), r.FOUR = r.from(\"0x4\"), r.A = r.from(\"0xA\");\nvar d = r;\nexport { g as a, d as b };\n//# sourceMappingURL=chunk-KM6UXNC7.mjs.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}