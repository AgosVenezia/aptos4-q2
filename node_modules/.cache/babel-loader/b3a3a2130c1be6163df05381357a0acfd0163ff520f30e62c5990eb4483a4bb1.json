{"ast":null,"code":"import { ACCEPT_HEADER, CONTENT_TYPE_GQL, CONTENT_TYPE_HEADER, CONTENT_TYPE_JSON } from '../../lib/http.js';\nimport { casesExhausted, uppercase, zip } from '../../lib/prelude.js';\nimport { ClientError } from '../classes/ClientError.js';\nimport { cleanQuery, isGraphQLContentType, isRequestResultHaveErrors, parseGraphQLExecutionResult } from '../lib/graphql.js';\nimport { defaultJsonSerializer } from './defaultJsonSerializer.js';\n// @ts-expect-error todo\nexport const runRequest = async input => {\n  // todo make a Config type\n  const config = {\n    ...input,\n    method: input.request._tag === `Single` ? input.request.document.isMutation ? `POST` : uppercase(input.method ?? `post`) : input.request.hasMutations ? `POST` : uppercase(input.method ?? `post`),\n    fetchOptions: {\n      ...input.fetchOptions,\n      errorPolicy: input.fetchOptions.errorPolicy ?? `none`\n    }\n  };\n  const fetcher = createFetcher(config.method);\n  const fetchResponse = await fetcher(config);\n  if (!fetchResponse.ok) {\n    return new ClientError({\n      status: fetchResponse.status,\n      headers: fetchResponse.headers\n    }, {\n      query: input.request._tag === `Single` ? input.request.document.expression : input.request.query,\n      variables: input.request.variables\n    });\n  }\n  const result = await parseResultFromResponse(fetchResponse, input.fetchOptions.jsonSerializer ?? defaultJsonSerializer);\n  if (result instanceof Error) throw result; // todo something better\n  const clientResponseBase = {\n    status: fetchResponse.status,\n    headers: fetchResponse.headers\n  };\n  if (isRequestResultHaveErrors(result) && config.fetchOptions.errorPolicy === `none`) {\n    // todo this client response on error is not consistent with the data type for success\n    const clientResponse = result._tag === `Batch` ? {\n      ...result.executionResults,\n      ...clientResponseBase\n    } : {\n      ...result.executionResult,\n      ...clientResponseBase\n    };\n    // @ts-expect-error todo\n    return new ClientError(clientResponse, {\n      query: input.request._tag === `Single` ? input.request.document.expression : input.request.query,\n      variables: input.request.variables\n    });\n  }\n  switch (result._tag) {\n    case `Single`:\n      // @ts-expect-error todo\n      return {\n        ...clientResponseBase,\n        ...executionResultClientResponseFields(config)(result.executionResult)\n      };\n    case `Batch`:\n      return {\n        ...clientResponseBase,\n        data: result.executionResults.map(executionResultClientResponseFields(config))\n      };\n    default:\n      casesExhausted(result);\n  }\n};\nconst executionResultClientResponseFields = $params => executionResult => {\n  return {\n    extensions: executionResult.extensions,\n    data: executionResult.data,\n    errors: $params.fetchOptions.errorPolicy === `all` ? executionResult.errors : undefined\n  };\n};\nconst parseResultFromResponse = async (response, jsonSerializer) => {\n  const contentType = response.headers.get(CONTENT_TYPE_HEADER);\n  const text = await response.text();\n  if (contentType && isGraphQLContentType(contentType)) {\n    return parseGraphQLExecutionResult(jsonSerializer.parse(text));\n  } else {\n    // todo what is this good for...? Seems very random/undefined\n    return parseGraphQLExecutionResult(text);\n  }\n};\nconst createFetcher = method => async params => {\n  const headers = new Headers(params.headers);\n  let searchParams = null;\n  let body = undefined;\n  if (!headers.has(ACCEPT_HEADER)) {\n    headers.set(ACCEPT_HEADER, [CONTENT_TYPE_GQL, CONTENT_TYPE_JSON].join(`, `));\n  }\n  if (method === `POST`) {\n    const $jsonSerializer = params.fetchOptions.jsonSerializer ?? defaultJsonSerializer;\n    body = $jsonSerializer.stringify(buildBody(params));\n    if (typeof body === `string` && !headers.has(CONTENT_TYPE_HEADER)) {\n      headers.set(CONTENT_TYPE_HEADER, CONTENT_TYPE_JSON);\n    }\n  } else {\n    searchParams = buildQueryParams(params);\n  }\n  const init = {\n    method,\n    headers,\n    body,\n    ...params.fetchOptions\n  };\n  let url = new URL(params.url);\n  let initResolved = init;\n  if (params.middleware) {\n    const result = await Promise.resolve(params.middleware({\n      ...init,\n      url: params.url,\n      operationName: params.request._tag === `Single` ? params.request.document.operationName : undefined,\n      variables: params.request.variables\n    }));\n    const {\n      url: urlNew,\n      ...initNew\n    } = result;\n    url = new URL(urlNew);\n    initResolved = initNew;\n  }\n  if (searchParams) {\n    searchParams.forEach((value, name) => {\n      url.searchParams.append(name, value);\n    });\n  }\n  const $fetch = params.fetch ?? fetch;\n  return await $fetch(url, initResolved);\n};\nconst buildBody = params => {\n  switch (params.request._tag) {\n    case `Single`:\n      return {\n        query: params.request.document.expression,\n        variables: params.request.variables,\n        operationName: params.request.document.operationName\n      };\n    case `Batch`:\n      return zip(params.request.query, params.request.variables ?? []).map(([query, variables]) => ({\n        query,\n        variables\n      }));\n    default:\n      throw casesExhausted(params.request);\n  }\n};\nconst buildQueryParams = params => {\n  const $jsonSerializer = params.fetchOptions.jsonSerializer ?? defaultJsonSerializer;\n  const searchParams = new URLSearchParams();\n  switch (params.request._tag) {\n    case `Single`:\n      {\n        searchParams.append(`query`, cleanQuery(params.request.document.expression));\n        if (params.request.variables) {\n          searchParams.append(`variables`, $jsonSerializer.stringify(params.request.variables));\n        }\n        if (params.request.document.operationName) {\n          searchParams.append(`operationName`, params.request.document.operationName);\n        }\n        return searchParams;\n      }\n    case `Batch`:\n      {\n        const variablesSerialized = params.request.variables?.map(v => $jsonSerializer.stringify(v)) ?? [];\n        const queriesCleaned = params.request.query.map(cleanQuery);\n        const payload = zip(queriesCleaned, variablesSerialized).map(([query, variables]) => ({\n          query,\n          variables\n        }));\n        searchParams.append(`query`, $jsonSerializer.stringify(payload));\n        return searchParams;\n      }\n    default:\n      throw casesExhausted(params.request);\n  }\n};\n//# sourceMappingURL=runRequest.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}