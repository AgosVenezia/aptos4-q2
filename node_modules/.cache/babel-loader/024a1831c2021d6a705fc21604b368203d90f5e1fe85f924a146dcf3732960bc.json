{"ast":null,"code":"import { a as y, f as P, g as C, i as b } from \"./chunk-22ZSW5EN.mjs\";\nimport { a as I } from \"./chunk-Y267I7DC.mjs\";\nimport { a as f } from \"./chunk-5SGSPCOY.mjs\";\nimport { a as w } from \"./chunk-3H5DGQKX.mjs\";\nimport { a as A } from \"./chunk-CDQGPCHU.mjs\";\nimport { d as h } from \"./chunk-WSZCPSV4.mjs\";\nimport { c as T, m as c } from \"./chunk-OTY3NO7Q.mjs\";\nimport { a as l } from \"./chunk-A2AEFKXS.mjs\";\nimport { b as d } from \"./chunk-2652SPOM.mjs\";\nimport { b as p } from \"./chunk-KM6UXNC7.mjs\";\nimport { a as s } from \"./chunk-IECDO22V.mjs\";\nimport { b as m } from \"./chunk-6FLHGOKP.mjs\";\nasync function S(t) {\n  let e = await K(t);\n  return U(t, e);\n}\nasync function K(t) {\n  let {\n      aptosConfig: e,\n      data: n\n    } = t,\n    a,\n    o;\n  return \"bytecode\" in n ? o = await y(n) : \"multisigAddress\" in n ? (a = {\n    aptosConfig: e,\n    multisigAddress: n.multisigAddress,\n    function: n.function,\n    functionArguments: n.functionArguments,\n    typeArguments: n.typeArguments,\n    abi: n.abi\n  }, o = await y(a)) : (a = {\n    aptosConfig: e,\n    function: n.function,\n    functionArguments: n.functionArguments,\n    typeArguments: n.typeArguments,\n    abi: n.abi\n  }, o = await y(a)), o;\n}\nasync function U(t, e) {\n  let {\n      aptosConfig: n,\n      sender: a,\n      options: o\n    } = t,\n    i;\n  if (_(t) && (i = p.ZERO.toString()), B(t)) {\n    let {\n      secondarySignerAddresses: r\n    } = t;\n    return P({\n      aptosConfig: n,\n      sender: a,\n      payload: e,\n      options: o,\n      secondarySignerAddresses: r,\n      feePayerAddress: i\n    });\n  }\n  return P({\n    aptosConfig: n,\n    sender: a,\n    payload: e,\n    options: o,\n    feePayerAddress: i\n  });\n}\nfunction _(t) {\n  return t.withFeePayer === !0;\n}\nfunction B(t) {\n  return \"secondarySignerAddresses\" in t;\n}\nfunction Y(t) {\n  let {\n    transaction: e\n  } = t;\n  return h(e);\n}\nfunction R(t) {\n  let {\n    signer: e,\n    transaction: n\n  } = t;\n  return e.signTransactionWithAuthenticator(n);\n}\nfunction x(t) {\n  let {\n    signer: e,\n    transaction: n\n  } = t;\n  if (!n.feePayerAddress) throw new Error(`Transaction ${n} is not a Fee Payer transaction`);\n  return n.feePayerAddress = e.accountAddress, R({\n    signer: e,\n    transaction: n\n  });\n}\nasync function nn(t) {\n  let {\n      aptosConfig: e,\n      transaction: n,\n      signerPublicKey: a,\n      secondarySignersPublicKeys: o,\n      feePayerPublicKey: i,\n      options: r\n    } = t,\n    u = C({\n      transaction: n,\n      signerPublicKey: a,\n      secondarySignersPublicKeys: o,\n      feePayerPublicKey: i,\n      options: r\n    }),\n    {\n      data: g\n    } = await d({\n      aptosConfig: e,\n      body: u,\n      path: \"transactions/simulate\",\n      params: {\n        estimate_gas_unit_price: t.options?.estimateGasUnitPrice ?? !1,\n        estimate_max_gas_amount: t.options?.estimateMaxGasAmount ?? !1,\n        estimate_prioritized_gas_unit_price: t.options?.estimatePrioritizedGasUnitPrice ?? !1\n      },\n      originMethod: \"simulateTransaction\",\n      contentType: \"application/x.aptos.signed_transaction+bcs\"\n    });\n  return g;\n}\nasync function F(t) {\n  let {\n      aptosConfig: e\n    } = t,\n    n = b({\n      ...t\n    }),\n    {\n      data: a\n    } = await d({\n      aptosConfig: e,\n      body: n,\n      path: \"transactions\",\n      originMethod: \"submitTransaction\",\n      contentType: \"application/x.aptos.signed_transaction+bcs\"\n    });\n  return a;\n}\nasync function M(t) {\n  let {\n    aptosConfig: e,\n    signer: n,\n    feePayer: a,\n    transaction: o\n  } = t;\n  (n instanceof A || n instanceof f) && (await n.waitForProofFetch()), (a instanceof A || a instanceof f) && (await a.waitForProofFetch());\n  let i = t.feePayerAuthenticator || a && x({\n      signer: a,\n      transaction: o\n    }),\n    r = R({\n      signer: n,\n      transaction: o\n    });\n  return F({\n    aptosConfig: e,\n    transaction: o,\n    senderAuthenticator: r,\n    feePayerAuthenticator: i\n  });\n}\nasync function tn(t) {\n  let {\n    aptosConfig: e,\n    senderAuthenticator: n,\n    feePayer: a,\n    transaction: o\n  } = t;\n  (a instanceof A || a instanceof f) && (await a.waitForProofFetch());\n  let i = x({\n    signer: a,\n    transaction: o\n  });\n  return F({\n    aptosConfig: e,\n    transaction: o,\n    senderAuthenticator: n,\n    feePayerAuthenticator: i\n  });\n}\nvar v = {\n  typeParameters: [],\n  parameters: [c.u8(), new c(c.u8())]\n};\nasync function en(t) {\n  let {\n      aptosConfig: e,\n      account: n,\n      metadataBytes: a,\n      moduleBytecode: o,\n      options: i\n    } = t,\n    r = o.map(u => s.U8(u));\n  return S({\n    aptosConfig: e,\n    sender: p.from(n),\n    data: {\n      function: \"0x1::code::publish_package_txn\",\n      functionArguments: [s.U8(a), new s(r)],\n      abi: v\n    },\n    options: i\n  });\n}\nvar N = {\n  typeParameters: [],\n  parameters: [new T(), c.u8(), new T(), c.u8(), c.u8(), c.u8()]\n};\nasync function an(t) {\n  let {\n      aptosConfig: e,\n      fromAccount: n,\n      toNewPrivateKey: a\n    } = t,\n    o = await I({\n      aptosConfig: e,\n      accountAddress: n.accountAddress\n    }),\n    i = w.fromPrivateKey({\n      privateKey: a,\n      legacy: !0\n    }),\n    u = new l({\n      sequenceNumber: BigInt(o.sequence_number),\n      originator: n.accountAddress,\n      currentAuthKey: p.from(o.authentication_key),\n      newPublicKey: i.publicKey\n    }).bcsToBytes(),\n    g = n.sign(u),\n    D = i.sign(u),\n    G = await S({\n      aptosConfig: e,\n      sender: n.accountAddress,\n      data: {\n        function: \"0x1::account::rotate_authentication_key\",\n        functionArguments: [new m(n.signingScheme), s.U8(n.publicKey.toUint8Array()), new m(i.signingScheme), s.U8(i.publicKey.toUint8Array()), s.U8(g.toUint8Array()), s.U8(D.toUint8Array())],\n        abi: N\n      }\n    });\n  return M({\n    aptosConfig: e,\n    signer: n,\n    transaction: G\n  });\n}\nexport { S as a, K as b, U as c, Y as d, R as e, x as f, nn as g, F as h, M as i, tn as j, en as k, an as l };\n//# sourceMappingURL=chunk-5S3Z7MT4.mjs.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}