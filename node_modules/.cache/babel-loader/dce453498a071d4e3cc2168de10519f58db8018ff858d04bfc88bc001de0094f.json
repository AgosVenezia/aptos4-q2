{"ast":null,"code":"import { a as j } from \"./chunk-5S3Z7MT4.mjs\";\nimport { g } from \"./chunk-Y267I7DC.mjs\";\nimport { a as S } from \"./chunk-GLATLXF6.mjs\";\nimport { a as l } from \"./chunk-M22UGFQ5.mjs\";\nimport { a as C } from \"./chunk-BOWPP6YG.mjs\";\nimport { i as K, l as k, m as A, n as x, p as b } from \"./chunk-FTZGP6XW.mjs\";\nimport { b as P } from \"./chunk-OAEDFM7T.mjs\";\nimport { e as h, f as w } from \"./chunk-2652SPOM.mjs\";\nimport { a as u } from \"./chunk-IECDO22V.mjs\";\nimport { b as c } from \"./chunk-KFNDDPOW.mjs\";\nimport { jwtDecode as E } from \"jwt-decode\";\nasync function v(o) {\n  let {\n      aptosConfig: s,\n      jwt: i,\n      ephemeralKeyPair: e,\n      uidKey: a = \"sub\",\n      derivationPath: p\n    } = o,\n    t = {\n      jwt_b64: i,\n      epk: e.getPublicKey().bcsToHex().toStringWithoutPrefix(),\n      exp_date_secs: e.expiryDateSecs,\n      epk_blinder: c.fromHexInput(e.blinder).toStringWithoutPrefix(),\n      uid_key: a,\n      derivation_path: p\n    },\n    {\n      data: r\n    } = await h({\n      aptosConfig: s,\n      path: \"fetch\",\n      body: t,\n      originMethod: \"getPepper\",\n      overrides: {\n        WITH_CREDENTIALS: !1\n      }\n    });\n  return c.fromHexInput(r.pepper).toUint8Array();\n}\nasync function _(o) {\n  let {\n    aptosConfig: s,\n    jwt: i,\n    ephemeralKeyPair: e,\n    pepper: a = await v(o),\n    uidKey: p = \"sub\"\n  } = o;\n  if (c.fromHexInput(a).toUint8Array().length !== l.PEPPER_LENGTH) throw new Error(`Pepper needs to be ${l.PEPPER_LENGTH} bytes`);\n  let {\n      maxExpHorizonSecs: t\n    } = await b({\n      aptosConfig: s\n    }),\n    r = E(i);\n  if (typeof r.iat != \"number\") throw new Error(\"iat was not found\");\n  if (t < e.expiryDateSecs - r.iat) throw Error(`The EphemeralKeyPair is too long lived.  It's lifespan must be less than ${t}`);\n  let n = {\n      jwt_b64: i,\n      epk: e.getPublicKey().bcsToHex().toStringWithoutPrefix(),\n      epk_blinder: c.fromHexInput(e.blinder).toStringWithoutPrefix(),\n      exp_date_secs: e.expiryDateSecs,\n      exp_horizon_secs: t,\n      pepper: c.fromHexInput(a).toStringWithoutPrefix(),\n      uid_key: p\n    },\n    {\n      data: f\n    } = await w({\n      aptosConfig: s,\n      path: \"prove\",\n      body: n,\n      originMethod: \"getProof\",\n      overrides: {\n        WITH_CREDENTIALS: !1\n      }\n    }),\n    d = f.proof,\n    y = new k({\n      a: d.a,\n      b: d.b,\n      c: d.c\n    });\n  return new x({\n    proof: new A(y, 0),\n    trainingWheelsSignature: P.fromHex(f.training_wheels_signature),\n    expHorizonSecs: t\n  });\n}\nasync function O(o) {\n  let {\n      aptosConfig: s,\n      jwt: i,\n      jwkAddress: e,\n      uidKey: a,\n      proofFetchCallback: p,\n      pepper: t = await v(o)\n    } = o,\n    r = _({\n      ...o,\n      pepper: t\n    }),\n    n = p ? r : await r;\n  if (e !== void 0) {\n    let y = C.fromJwtAndPepper({\n        jwt: i,\n        pepper: t,\n        jwkAddress: e,\n        uidKey: a\n      }),\n      m = await g({\n        aptosConfig: s,\n        authenticationKey: y.authKey().derivedAddress()\n      });\n    return S.create({\n      ...o,\n      address: m,\n      proof: n,\n      pepper: t,\n      proofFetchCallback: p,\n      jwkAddress: e\n    });\n  }\n  let f = K.fromJwtAndPepper({\n      jwt: i,\n      pepper: t,\n      uidKey: a\n    }),\n    d = await g({\n      aptosConfig: s,\n      authenticationKey: f.authKey().derivedAddress()\n    });\n  return l.create({\n    ...o,\n    address: d,\n    proof: n,\n    pepper: t,\n    proofFetchCallback: p\n  });\n}\nasync function V(o) {\n  let {\n      aptosConfig: s,\n      sender: i,\n      iss: e,\n      options: a\n    } = o,\n    p = o.jwksUrl ?? (e.endsWith(\"/\") ? `${e}.well-known/jwks.json` : `${e}/.well-known/jwks.json`),\n    t = await fetch(p);\n  if (!t.ok) throw new Error(`Failed to fetch JWKS: ${t.status} ${t.statusText}`);\n  let r = await t.json();\n  return j({\n    aptosConfig: s,\n    sender: i.accountAddress,\n    data: {\n      function: \"0x1::jwks::update_federated_jwk_set\",\n      functionArguments: [e, u.MoveString(r.keys.map(n => n.kid)), u.MoveString(r.keys.map(n => n.alg)), u.MoveString(r.keys.map(n => n.e)), u.MoveString(r.keys.map(n => n.n))]\n    },\n    options: a\n  });\n}\nexport { v as a, _ as b, O as c, V as d };\n//# sourceMappingURL=chunk-BAGUHYFD.mjs.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}