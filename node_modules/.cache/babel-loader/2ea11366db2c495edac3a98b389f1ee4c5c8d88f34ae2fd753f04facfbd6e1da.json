{"ast":null,"code":"import { a as h, c as sn, d as cn, e as R } from \"./chunk-DMSHPWA5.mjs\";\nimport { r as on, u as A } from \"./chunk-IFXUWUP2.mjs\";\nimport { a as an } from \"./chunk-Y267I7DC.mjs\";\nimport { b as rn } from \"./chunk-T5BCTWGK.mjs\";\nimport { a as en } from \"./chunk-BVVHGSWC.mjs\";\nimport { a as y } from \"./chunk-F2RY4YQ7.mjs\";\nimport { a as nn } from \"./chunk-XQ7ONNII.mjs\";\nimport { a as tn } from \"./chunk-RBJNSUSU.mjs\";\nimport { a as J, c as Q, d as Y } from \"./chunk-4LKLOUMG.mjs\";\nimport { c as H, d as X, e as z, f as x, g as L, h as Z, i as j } from \"./chunk-ZPIMARUG.mjs\";\nimport { a as q } from \"./chunk-ZINOJTLU.mjs\";\nimport { b as B, d as F, e as D, f as M } from \"./chunk-SGQFWWLQ.mjs\";\nimport { a as V, b as p, d as l, e as E } from \"./chunk-MK2QAHXC.mjs\";\nimport { a as k, b as O } from \"./chunk-6DMDYBV6.mjs\";\nimport { a as b, b as g } from \"./chunk-TPJLAYW6.mjs\";\nimport { a as N } from \"./chunk-4VU2ABLU.mjs\";\nimport { a as v } from \"./chunk-BOWPP6YG.mjs\";\nimport { i as S, j as C } from \"./chunk-FTZGP6XW.mjs\";\nimport { b as $, d as K } from \"./chunk-P3J54CQG.mjs\";\nimport { a as _ } from \"./chunk-HBIDHQ2M.mjs\";\nimport { a as U } from \"./chunk-4CDDWSKZ.mjs\";\nimport { g as I } from \"./chunk-D3OEQLUE.mjs\";\nimport { b as W, c as G } from \"./chunk-J245N3XF.mjs\";\nimport { b as u } from \"./chunk-KM6UXNC7.mjs\";\nimport { b as P } from \"./chunk-KFNDDPOW.mjs\";\nimport { sha3_256 as fn } from \"@noble/hashes/sha3\";\nasync function qn(n) {\n  if (on(n)) return ln(n);\n  let {\n      moduleAddress: e,\n      moduleName: t,\n      functionName: i\n    } = A(n.function),\n    a = await dn({\n      key: \"entry-function\",\n      moduleAddress: e,\n      moduleName: t,\n      functionName: i,\n      aptosConfig: n.aptosConfig,\n      abi: n.abi,\n      fetch: sn\n    });\n  return gn({\n    ...n,\n    abi: a\n  });\n}\nfunction gn(n) {\n  let e = n.abi,\n    {\n      moduleAddress: t,\n      moduleName: i,\n      functionName: a\n    } = A(n.function),\n    r = h(n.typeArguments);\n  if (r.length !== e.typeParameters.length) throw new Error(`Type argument count mismatch, expected ${e.typeParameters.length}, received ${r.length}`);\n  let o = n.functionArguments.map((s, d) => R(n.function, e, s, d, r));\n  if (o.length !== e.parameters.length) throw new Error(`Too few arguments for '${t}::${i}::${a}', expected ${e.parameters.length} but got ${o.length}`);\n  let c = x.build(`${t}::${i}`, a, r, o);\n  if (\"multisigAddress\" in n) {\n    let s = u.from(n.multisigAddress);\n    return new z(new Z(s, new j(c)));\n  }\n  return new X(c);\n}\nasync function Hn(n) {\n  let {\n      moduleAddress: e,\n      moduleName: t,\n      functionName: i\n    } = A(n.function),\n    a = await dn({\n      key: \"view-function\",\n      moduleAddress: e,\n      moduleName: t,\n      functionName: i,\n      aptosConfig: n.aptosConfig,\n      abi: n.abi,\n      fetch: cn\n    });\n  return pn({\n    abi: a,\n    ...n\n  });\n}\nfunction pn(n) {\n  let e = n.abi,\n    {\n      moduleAddress: t,\n      moduleName: i,\n      functionName: a\n    } = A(n.function),\n    r = h(n.typeArguments);\n  if (r.length !== e.typeParameters.length) throw new Error(`Type argument count mismatch, expected ${e.typeParameters.length}, received ${r.length}`);\n  let o = n?.functionArguments?.map((c, s) => R(n.function, e, c, s, r)) ?? [];\n  if (o.length !== e.parameters.length) throw new Error(`Too few arguments for '${t}::${i}::${a}', expected ${e.parameters.length} but got ${o.length}`);\n  return x.build(`${t}::${i}`, a, r, o);\n}\nfunction ln(n) {\n  return new H(new L(P.fromHexInput(n.bytecode).toUint8Array(), h(n.typeArguments), n.functionArguments));\n}\nasync function hn(n) {\n  let {\n      aptosConfig: e,\n      sender: t,\n      payload: i,\n      options: a,\n      feePayerAddress: r\n    } = n,\n    o = async () => I[e.network] ? {\n      chainId: I[e.network]\n    } : {\n      chainId: (await en({\n        aptosConfig: e\n      })).chain_id\n    },\n    c = async () => a?.gasUnitPrice ? {\n      gasEstimate: a.gasUnitPrice\n    } : {\n      gasEstimate: (await rn({\n        aptosConfig: e\n      })).gas_estimate\n    },\n    s = async () => {\n      let f = async () => a?.accountSequenceNumber !== void 0 ? a.accountSequenceNumber : (await an({\n        aptosConfig: e,\n        accountAddress: t\n      })).sequence_number;\n      if (r && u.from(r).equals(u.ZERO)) try {\n        return await f();\n      } catch {\n        return 0;\n      } else return f();\n    },\n    [{\n      chainId: d\n    }, {\n      gasEstimate: m\n    }, w] = await Promise.all([o(), c(), s()]),\n    {\n      maxGasAmount: mn,\n      gasUnitPrice: yn,\n      expireTimestamp: An\n    } = {\n      maxGasAmount: a?.maxGasAmount ? BigInt(a.maxGasAmount) : BigInt(2e5),\n      gasUnitPrice: a?.gasUnitPrice ?? BigInt(m),\n      expireTimestamp: a?.expireTimestamp ?? BigInt(Math.floor(Date.now() / 1e3) + 20)\n    };\n  return new J(u.from(t), BigInt(w), i, BigInt(mn), BigInt(yn), BigInt(An), new q(d));\n}\nasync function Xn(n) {\n  let {\n      aptosConfig: e,\n      sender: t,\n      payload: i,\n      options: a,\n      feePayerAddress: r\n    } = n,\n    o = await hn({\n      aptosConfig: e,\n      sender: t,\n      payload: i,\n      options: a,\n      feePayerAddress: r\n    });\n  if (\"secondarySignerAddresses\" in n) {\n    let c = n.secondarySignerAddresses?.map(s => u.from(s)) ?? [];\n    return new tn(o, c, n.feePayerAddress ? u.from(n.feePayerAddress) : void 0);\n  }\n  return new nn(o, n.feePayerAddress ? u.from(n.feePayerAddress) : void 0);\n}\nfunction zn(n) {\n  let {\n      signerPublicKey: e,\n      transaction: t,\n      secondarySignersPublicKeys: i,\n      feePayerPublicKey: a\n    } = n,\n    r = T(e);\n  if (t.feePayerAddress) {\n    let c = new Y(t.rawTransaction, t.secondarySignerAddresses ?? [], t.feePayerAddress),\n      s = [];\n    if (i && (s = i.map(w => T(w))), !a) throw new Error(\"Must provide a feePayerPublicKey argument to generate a signed fee payer transaction for simulation\");\n    let d = T(a),\n      m = new D(r, t.secondarySignerAddresses ?? [], s, {\n        address: t.feePayerAddress,\n        authenticator: d\n      });\n    return new y(c.raw_txn, m).bcsToBytes();\n  }\n  if (t.secondarySignerAddresses) {\n    let c = new Q(t.rawTransaction, t.secondarySignerAddresses),\n      s = [];\n    if (!i) throw new Error(\"Must provide a secondarySignersPublicKeys argument to generate a signed multi agent transaction for simulation\");\n    s = i.map(m => T(m));\n    let d = new F(r, t.secondarySignerAddresses, s);\n    return new y(c.raw_txn, d).bcsToBytes();\n  }\n  let o;\n  if (r instanceof p) o = new B(r.public_key, r.signature);else if (r instanceof l || r instanceof E) o = new M(r);else throw new Error(\"Invalid public key\");\n  return new y(t.rawTransaction, o).bcsToBytes();\n}\nfunction T(n) {\n  let t = S.isInstance(n) || v.isInstance(n) || N.isInstance(n) ? new b(n) : n,\n    i = new K(new Uint8Array(64));\n  if ($.isInstance(t)) return new p(t, i);\n  if (b.isInstance(t)) return S.isInstance(t.publicKey) ? new l(t, new g(C.getSimulationSignature())) : new l(t, new g(i));\n  if (k.isInstance(t)) return new E(t, new O({\n    signatures: t.publicKeys.map(() => new g(i)),\n    bitmap: t.createBitmap({\n      bits: Array(t.publicKeys.length).fill(0).map((a, r) => r)\n    })\n  }));\n  throw new Error(\"Unsupported PublicKey used for simulations\");\n}\nfunction Tn(n) {\n  let {\n      transaction: e,\n      feePayerAuthenticator: t,\n      additionalSignersAuthenticators: i\n    } = n,\n    a = U(V, n.senderAuthenticator),\n    r;\n  if (e.feePayerAddress) {\n    if (!t) throw new Error(\"Must provide a feePayerAuthenticator argument to generate a signed fee payer transaction\");\n    r = new D(a, e.secondarySignerAddresses ?? [], i ?? [], {\n      address: e.feePayerAddress,\n      authenticator: t\n    });\n  } else if (e.secondarySignerAddresses) {\n    if (!i) throw new Error(\"Must provide a additionalSignersAuthenticators argument to generate a signed multi agent transaction\");\n    r = new F(a, e.secondarySignerAddresses, i);\n  } else a instanceof p ? r = new B(a.public_key, a.signature) : r = new M(a);\n  return new y(e.rawTransaction, r).bcsToBytes();\n}\nfunction un(n) {\n  let e = fn.create();\n  for (let t of n) e.update(t);\n  return e.digest();\n}\nvar wn = un([\"APTOS::Transaction\"]);\nfunction Ln(n) {\n  let e = Tn(n);\n  return new P(un([wn, new Uint8Array([0]), e])).toString();\n}\nasync function dn({\n  key: n,\n  moduleAddress: e,\n  moduleName: t,\n  functionName: i,\n  aptosConfig: a,\n  abi: r,\n  fetch: o\n}) {\n  return r !== void 0 ? r : _(async () => o(e, t, i, a), `${n}-${a.network}-${e}-${t}-${i}`, 1e3 * 60 * 5)();\n}\nexport { qn as a, gn as b, Hn as c, pn as d, hn as e, Xn as f, zn as g, T as h, Tn as i, un as j, Ln as k };\n//# sourceMappingURL=chunk-22ZSW5EN.mjs.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}