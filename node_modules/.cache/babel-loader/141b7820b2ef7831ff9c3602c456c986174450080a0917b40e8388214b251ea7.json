{"ast":null,"code":"import { b as y, c as f, d as x, e as v, f as A, g as C, h as U, i as b, j as I, k as M, l as P, m as E, n as G, o as N } from \"./chunk-OTY3NO7Q.mjs\";\nimport { a as l } from \"./chunk-AGBA3Y7A.mjs\";\nimport { b as w } from \"./chunk-KM6UXNC7.mjs\";\nfunction V(e) {\n  return !!e.match(/^[_a-zA-Z0-9]+$/);\n}\nfunction W(e) {\n  return !!e.match(/\\s/);\n}\nfunction $(e) {\n  return !!e.match(/^T[0-9]+$/);\n}\nfunction F(e) {\n  return !!e.match(/^&.+$/);\n}\nfunction k(e) {\n  switch (e) {\n    case \"signer\":\n    case \"address\":\n    case \"bool\":\n    case \"u8\":\n    case \"u16\":\n    case \"u32\":\n    case \"u64\":\n    case \"u128\":\n    case \"u256\":\n      return !0;\n    default:\n      return !1;\n  }\n}\nfunction L(e, i) {\n  let c = i;\n  for (; c < e.length; c += 1) {\n    let s = e[c];\n    if (!W(s)) break;\n  }\n  return c;\n}\nvar R = (a => (a.InvalidTypeTag = \"unknown type\", a.UnexpectedGenericType = \"unexpected generic type\", a.UnexpectedTypeArgumentClose = \"unexpected '>'\", a.UnexpectedWhitespaceCharacter = \"unexpected whitespace character\", a.UnexpectedComma = \"unexpected ','\", a.TypeArgumentCountMismatch = \"type argument count doesn't match expected amount\", a.MissingTypeArgumentClose = \"no matching '>' for '<'\", a.MissingTypeArgument = \"no type argument before ','\", a.UnexpectedPrimitiveTypeArguments = \"primitive types not expected to have type arguments\", a.UnexpectedVectorTypeArgumentCount = \"vector type expected to have exactly one type argument\", a.UnexpectedStructFormat = \"unexpected struct format, must be of the form 0xaddress::module_name::struct_name\", a.InvalidModuleNameCharacter = \"module name must only contain alphanumeric or '_' characters\", a.InvalidStructNameCharacter = \"struct name must only contain alphanumeric or '_' characters\", a.InvalidAddress = \"struct address must be valid\", a))(R || {}),\n  t = class extends Error {\n    constructor(i, c) {\n      super(`Failed to parse typeTag '${i}', ${c}`);\n    }\n  };\nfunction j(e, i) {\n  let c = i?.allowGenerics ?? !1,\n    s = [],\n    u = [],\n    n = [],\n    o = 0,\n    r = \"\",\n    T = 1;\n  for (; o < e.length;) {\n    let d = e[o];\n    if (d === \"<\") s.push({\n      savedExpectedTypes: T,\n      savedStr: r,\n      savedTypes: n\n    }), r = \"\", n = [], T = 1;else if (d === \">\") {\n      if (r !== \"\") {\n        let a = g(r, u, c);\n        n.push(a);\n      }\n      let p = s.pop();\n      if (p === void 0) throw new t(e, \"unexpected '>'\");\n      if (T !== n.length) throw new t(e, \"type argument count doesn't match expected amount\");\n      let {\n        savedStr: m,\n        savedTypes: h,\n        savedExpectedTypes: _\n      } = p;\n      u = n, n = h, r = m, T = _;\n    } else if (d === \",\") {\n      if (s.length === 0) throw new t(e, \"unexpected ','\");\n      if (r.length === 0) throw new t(e, \"no type argument before ','\");\n      let p = g(r, u, c);\n      u = [], n.push(p), r = \"\", T += 1;\n    } else if (W(d)) {\n      let p = !1;\n      if (r.length !== 0) {\n        let h = g(r, u, c);\n        u = [], n.push(h), r = \"\", p = !0;\n      }\n      o = L(e, o);\n      let m = e[o];\n      if (o < e.length && p && m !== \",\" && m !== \">\") throw new t(e, \"unexpected whitespace character\");\n      continue;\n    } else r += d;\n    o += 1;\n  }\n  if (s.length > 0) throw new t(e, \"no matching '>' for '<'\");\n  switch (n.length) {\n    case 0:\n      return g(r, u, c);\n    case 1:\n      if (r === \"\") return n[0];\n      throw new t(e, \"unexpected ','\");\n    default:\n      throw new t(e, \"unexpected whitespace character\");\n  }\n}\nfunction g(e, i, c) {\n  let s = e.trim(),\n    u = s.toLowerCase();\n  if (k(u) && i.length > 0) throw new t(e, \"primitive types not expected to have type arguments\");\n  switch (s.toLowerCase()) {\n    case \"signer\":\n      return new I();\n    case \"bool\":\n      return new y();\n    case \"address\":\n      return new b();\n    case \"u8\":\n      return new f();\n    case \"u16\":\n      return new x();\n    case \"u32\":\n      return new v();\n    case \"u64\":\n      return new A();\n    case \"u128\":\n      return new C();\n    case \"u256\":\n      return new U();\n    case \"vector\":\n      if (i.length !== 1) throw new t(e, \"vector type expected to have exactly one type argument\");\n      return new E(i[0]);\n    default:\n      if (F(s)) {\n        let r = s.substring(1);\n        return new M(g(r, i, c));\n      }\n      if ($(s)) {\n        if (c) return new P(Number(s.split(\"T\")[1]));\n        throw new t(e, \"unexpected generic type\");\n      }\n      if (!s.match(/:/)) throw new t(e, \"unknown type\");\n      let n = s.split(\"::\");\n      if (n.length !== 3) throw new t(e, \"unexpected struct format, must be of the form 0xaddress::module_name::struct_name\");\n      let o;\n      try {\n        o = w.fromString(n[0]);\n      } catch {\n        throw new t(e, \"struct address must be valid\");\n      }\n      if (!V(n[1])) throw new t(e, \"module name must only contain alphanumeric or '_' characters\");\n      if (!V(n[2])) throw new t(e, \"struct name must only contain alphanumeric or '_' characters\");\n      return new G(new N(o, new l(n[1]), new l(n[2]), i));\n  }\n}\nexport { R as a, t as b, j as c };\n//# sourceMappingURL=chunk-KRVLR3L4.mjs.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}