{"ast":null,"code":"import { e as x, f as B } from \"./chunk-BVVHGSWC.mjs\";\nimport { a as k } from \"./chunk-HBIDHQ2M.mjs\";\nimport { b as f, d as A } from \"./chunk-RNJHULIT.mjs\";\nimport { a as b } from \"./chunk-GQABU3RQ.mjs\";\nimport { d as C } from \"./chunk-J245N3XF.mjs\";\nimport { a as d } from \"./chunk-LEKBJ2EG.mjs\";\nasync function H(o) {\n  let {\n    aptosConfig: n,\n    options: t\n  } = o;\n  return A({\n    aptosConfig: n,\n    originMethod: \"getTransactions\",\n    path: \"transactions\",\n    params: {\n      start: t?.offset,\n      limit: t?.limit\n    }\n  });\n}\nasync function G(o) {\n  let {\n    aptosConfig: n\n  } = o;\n  return k(async () => {\n    let {\n      data: t\n    } = await f({\n      aptosConfig: n,\n      originMethod: \"getGasPriceEstimation\",\n      path: \"estimate_gas_price\"\n    });\n    return t;\n  }, `gas-price-${n.network}`, 1e3 * 60 * 5)();\n}\nasync function W(o) {\n  let {\n      aptosConfig: n,\n      ledgerVersion: t\n    } = o,\n    {\n      data: s\n    } = await f({\n      aptosConfig: n,\n      originMethod: \"getTransactionByVersion\",\n      path: `transactions/by_version/${t}`\n    });\n  return s;\n}\nasync function y(o) {\n  let {\n      aptosConfig: n,\n      transactionHash: t\n    } = o,\n    {\n      data: s\n    } = await f({\n      aptosConfig: n,\n      path: `transactions/by_hash/${t}`,\n      originMethod: \"getTransactionByHash\"\n    });\n  return s;\n}\nasync function O(o) {\n  let {\n    aptosConfig: n,\n    transactionHash: t\n  } = o;\n  try {\n    return (await y({\n      aptosConfig: n,\n      transactionHash: t\n    })).type === \"pending_transaction\";\n  } catch (s) {\n    if (s?.status === 404) return !0;\n    throw s;\n  }\n}\nasync function R(o) {\n  let {\n      aptosConfig: n,\n      transactionHash: t\n    } = o,\n    {\n      data: s\n    } = await f({\n      aptosConfig: n,\n      path: `transactions/wait_by_hash/${t}`,\n      originMethod: \"longWaitForTransaction\"\n    });\n  return s;\n}\nasync function q(o) {\n  let {\n      aptosConfig: n,\n      transactionHash: t,\n      options: s\n    } = o,\n    r = s?.timeoutSecs ?? 20,\n    u = s?.checkSuccess ?? !0,\n    e = !0,\n    p = 0,\n    i,\n    g,\n    l = 200,\n    h = 1.5;\n  function c(a) {\n    if (!(a instanceof b) || (g = a, a.status !== 404 && a.status >= 400 && a.status < 500)) throw a;\n  }\n  try {\n    i = await y({\n      aptosConfig: n,\n      transactionHash: t\n    }), e = i.type === \"pending_transaction\";\n  } catch (a) {\n    c(a);\n  }\n  if (e) {\n    let a = Date.now();\n    try {\n      i = await R({\n        aptosConfig: n,\n        transactionHash: t\n      }), e = i.type === \"pending_transaction\";\n    } catch (w) {\n      c(w);\n    }\n    p = (Date.now() - a) / 1e3;\n  }\n  for (; e && !(p >= r);) {\n    try {\n      if (i = await y({\n        aptosConfig: n,\n        transactionHash: t\n      }), e = i.type === \"pending_transaction\", !e) break;\n    } catch (a) {\n      c(a);\n    }\n    await d(l), p += l / 1e3, l *= h;\n  }\n  if (i === void 0) throw g || new m(`Fetching transaction ${t} failed and timed out after ${r} seconds`, i);\n  if (i.type === \"pending_transaction\") throw new m(`Transaction ${t} timed out in pending state after ${r} seconds`, i);\n  if (!u) return i;\n  if (!i.success) throw new T(`Transaction ${t} failed with an error: ${i.vm_status}`, i);\n  return i;\n}\nasync function z(o) {\n  let {\n      aptosConfig: n,\n      processorType: t\n    } = o,\n    s = BigInt(o.minimumLedgerVersion),\n    r = 3e3,\n    u = new Date().getTime(),\n    e = BigInt(-1);\n  for (; e < s;) {\n    if (new Date().getTime() - u > r) throw new Error(\"waitForLastSuccessIndexerVersionSync timeout\");\n    if (t === void 0 ? e = await x({\n      aptosConfig: n\n    }) : e = (await B({\n      aptosConfig: n,\n      processorType: t\n    })).last_success_version, e >= s) break;\n    await d(200);\n  }\n}\nvar m = class extends Error {\n    constructor(n, t) {\n      super(n), this.lastSubmittedTransaction = t;\n    }\n  },\n  T = class extends Error {\n    constructor(n, t) {\n      super(n), this.transaction = t;\n    }\n  };\nasync function U(o) {\n  let {\n      aptosConfig: n,\n      ledgerVersion: t,\n      options: s\n    } = o,\n    {\n      data: r\n    } = await f({\n      aptosConfig: n,\n      originMethod: \"getBlockByVersion\",\n      path: `blocks/by_version/${t}`,\n      params: {\n        with_transactions: s?.withTransactions\n      }\n    });\n  return P({\n    block: r,\n    ...o\n  });\n}\nasync function X(o) {\n  let {\n      aptosConfig: n,\n      blockHeight: t,\n      options: s\n    } = o,\n    {\n      data: r\n    } = await f({\n      aptosConfig: n,\n      originMethod: \"getBlockByHeight\",\n      path: `blocks/by_height/${t}`,\n      params: {\n        with_transactions: s?.withTransactions\n      }\n    });\n  return P({\n    block: r,\n    ...o\n  });\n}\nasync function P(o) {\n  let {\n    aptosConfig: n,\n    block: t,\n    options: s\n  } = o;\n  if (s?.withTransactions) {\n    t.transactions = t.transactions ?? [];\n    let r = t.transactions[t.transactions.length - 1],\n      u = BigInt(t.first_version),\n      e = BigInt(t.last_version),\n      p = r?.version,\n      i;\n    if (p === void 0 ? i = u - 1n : i = BigInt(p), i === e) return t;\n    let g = [],\n      l = 100n;\n    for (let c = i + 1n; c < e; c += BigInt(100)) g.push(H({\n      aptosConfig: n,\n      options: {\n        offset: c,\n        limit: Math.min(Number(l), Number(e - c + 1n))\n      }\n    }));\n    let h = await Promise.all(g);\n    for (let c of h) t.transactions.push(...c);\n  }\n  return t;\n}\nexport { H as a, G as b, W as c, y as d, O as e, R as f, q as g, z as h, m as i, T as j, U as k, X as l };\n//# sourceMappingURL=chunk-T5BCTWGK.mjs.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}