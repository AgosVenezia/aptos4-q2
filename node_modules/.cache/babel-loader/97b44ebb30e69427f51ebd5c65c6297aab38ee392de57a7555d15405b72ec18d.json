{"ast":null,"code":"import { a as l } from \"./chunk-ZPQUCT22.mjs\";\nimport { a as o, b as c } from \"./chunk-2CJC43CV.mjs\";\nimport { a as h, i as d } from \"./chunk-5S3Z7MT4.mjs\";\nimport { g as u } from \"./chunk-T5BCTWGK.mjs\";\nimport g from \"eventemitter3\";\nvar m = \"fulfilled\",\n  f = (n => (n.TransactionSent = \"transactionSent\", n.TransactionSendFailed = \"transactionSendFailed\", n.TransactionExecuted = \"transactionExecuted\", n.TransactionExecutionFailed = \"transactionExecutionFailed\", n.ExecutionFinish = \"executionFinish\", n))(f || {}),\n  p = class extends g {\n    constructor(t, e, a = 30, n = 100, i = 10) {\n      super();\n      this.taskQueue = new o();\n      this.transactionsQueue = new o();\n      this.outstandingTransactions = new o();\n      this.sentTransactions = [];\n      this.executedTransactions = [];\n      this.aptosConfig = t, this.account = e, this.started = !1, this.accountSequnceNumber = new l(t, e, a, n, i);\n    }\n    async submitNextTransaction() {\n      try {\n        for (;;) {\n          let t = await this.accountSequnceNumber.nextSequenceNumber();\n          if (t === null) return;\n          let e = await this.generateNextTransaction(this.account, t);\n          if (!e) return;\n          let a = d({\n            aptosConfig: this.aptosConfig,\n            transaction: e,\n            signer: this.account\n          });\n          await this.outstandingTransactions.enqueue([a, t]);\n        }\n      } catch (t) {\n        if (t instanceof c) return;\n        throw new Error(`Submit transaction failed for ${this.account.accountAddress.toString()} with error ${t}`);\n      }\n    }\n    async processTransactions() {\n      try {\n        for (;;) {\n          let t = [],\n            e = [],\n            [a, n] = await this.outstandingTransactions.dequeue();\n          for (t.push(a), e.push(n); !this.outstandingTransactions.isEmpty();) [a, n] = await this.outstandingTransactions.dequeue(), t.push(a), e.push(n);\n          let i = await Promise.allSettled(t);\n          for (let s = 0; s < i.length && s < e.length; s += 1) {\n            let r = i[s];\n            n = e[s], r.status === m ? (this.sentTransactions.push([r.value.hash, n, null]), this.emit(\"transactionSent\", {\n              message: `transaction hash ${r.value.hash} has been committed to chain`,\n              transactionHash: r.value.hash\n            }), await this.checkTransaction(r, n)) : (this.sentTransactions.push([r.status, n, r.reason]), this.emit(\"transactionSendFailed\", {\n              message: `failed to commit transaction ${this.sentTransactions.length} with error ${r.reason}`,\n              error: r.reason\n            }));\n          }\n          this.emit(\"executionFinish\", {\n            message: `execute ${i.length} transactions finished`\n          });\n        }\n      } catch (t) {\n        if (t instanceof c) return;\n        throw new Error(`Process execution failed for ${this.account.accountAddress.toString()} with error ${t}`);\n      }\n    }\n    async checkTransaction(t, e) {\n      try {\n        let a = [];\n        a.push(u({\n          aptosConfig: this.aptosConfig,\n          transactionHash: t.value.hash\n        }));\n        let n = await Promise.allSettled(a);\n        for (let i = 0; i < n.length; i += 1) {\n          let s = n[i];\n          s.status === m ? (this.executedTransactions.push([s.value.hash, e, null]), this.emit(\"transactionExecuted\", {\n            message: `transaction hash ${s.value.hash} has been executed on chain`,\n            transactionHash: t.value.hash\n          })) : (this.executedTransactions.push([s.status, e, s.reason]), this.emit(\"transactionExecutionFailed\", {\n            message: `failed to execute transaction ${this.executedTransactions.length} with error ${s.reason}`,\n            error: s.reason\n          }));\n        }\n      } catch (a) {\n        throw new Error(`Check transaction failed for ${this.account.accountAddress.toString()} with error ${a}`);\n      }\n    }\n    async push(t, e) {\n      this.transactionsQueue.enqueue([t, e]);\n    }\n    async generateNextTransaction(t, e) {\n      if (this.transactionsQueue.isEmpty()) return;\n      let [a, n] = await this.transactionsQueue.dequeue();\n      return h({\n        aptosConfig: this.aptosConfig,\n        sender: t.accountAddress,\n        data: a,\n        options: {\n          ...n,\n          accountSequenceNumber: e\n        }\n      });\n    }\n    async run() {\n      try {\n        for (; !this.taskQueue.isCancelled();) await (await this.taskQueue.dequeue())();\n      } catch (t) {\n        throw new Error(`Unable to start transaction batching: ${t}`);\n      }\n    }\n    start() {\n      if (this.started) throw new Error(\"worker has already started\");\n      this.started = !0, this.taskQueue.enqueue(() => this.submitNextTransaction()), this.taskQueue.enqueue(() => this.processTransactions()), this.run();\n    }\n    stop() {\n      if (this.taskQueue.isCancelled()) throw new Error(\"worker has already stopped\");\n      this.started = !1, this.taskQueue.cancel();\n    }\n  };\nexport { m as a, f as b, p as c };\n//# sourceMappingURL=chunk-4JXB6V5O.mjs.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}