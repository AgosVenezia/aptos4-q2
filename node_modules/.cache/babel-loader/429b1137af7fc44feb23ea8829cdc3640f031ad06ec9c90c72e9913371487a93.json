{"ast":null,"code":"import { a as f } from \"./chunk-IBLZ6MZU.mjs\";\nimport { a as u } from \"./chunk-KIW54KWR.mjs\";\nimport { a as d } from \"./chunk-4OV7QU2U.mjs\";\nimport { e as g, j as h } from \"./chunk-PHP47DI4.mjs\";\nimport { a as p } from \"./chunk-QQIVWB6G.mjs\";\nimport { b as s } from \"./chunk-KFNDDPOW.mjs\";\nimport { sha3_256 as H } from \"@noble/hashes/sha3\";\nimport { secp256k1 as o } from \"@noble/curves/secp256k1\";\nimport { HDKey as z } from \"@scure/bip32\";\nvar i = class i extends d {\n  constructor(e) {\n    super();\n    let t = s.fromHexInput(e);\n    if (t.toUint8Array().length !== i.LENGTH) throw new Error(`PublicKey length should be ${i.LENGTH}`);\n    this.key = t;\n  }\n  verifySignature(e) {\n    let {\n        message: t,\n        signature: n\n      } = e,\n      l = u(t),\n      c = s.fromHexInput(l).toUint8Array(),\n      x = H(c),\n      A = n.toUint8Array();\n    return o.verify(A, x, this.key.toUint8Array(), {\n      lowS: !0\n    });\n  }\n  toUint8Array() {\n    return this.key.toUint8Array();\n  }\n  serialize(e) {\n    e.serializeBytes(this.key.toUint8Array());\n  }\n  deserialize(e) {\n    let t = e.deserializeBytes();\n    return new y(t);\n  }\n  static deserialize(e) {\n    let t = e.deserializeBytes();\n    return new i(t);\n  }\n  static isPublicKey(e) {\n    return e instanceof i;\n  }\n  static isInstance(e) {\n    return \"key\" in e && e.key?.data?.length === i.LENGTH;\n  }\n};\ni.LENGTH = 65;\nvar m = i,\n  r = class r extends p {\n    constructor(e) {\n      super();\n      let t = s.fromHexInput(e);\n      if (t.toUint8Array().length !== r.LENGTH) throw new Error(`PrivateKey length should be ${r.LENGTH}`);\n      this.key = t;\n    }\n    static generate() {\n      let e = o.utils.randomPrivateKey();\n      return new r(e);\n    }\n    static fromDerivationPath(e, t) {\n      if (!g(e)) throw new Error(`Invalid derivation path ${e}`);\n      return r.fromDerivationPathInner(e, h(t));\n    }\n    static fromDerivationPathInner(e, t) {\n      let {\n        privateKey: n\n      } = z.fromMasterSeed(t).derive(e);\n      if (n === null) throw new Error(\"Invalid key\");\n      return new r(n);\n    }\n    sign(e) {\n      let t = u(e),\n        n = s.fromHexInput(t),\n        l = H(n.toUint8Array()),\n        c = o.sign(l, this.key.toUint8Array(), {\n          lowS: !0\n        });\n      return new y(c.toCompactRawBytes());\n    }\n    publicKey() {\n      let e = o.getPublicKey(this.key.toUint8Array(), !1);\n      return new m(e);\n    }\n    toUint8Array() {\n      return this.key.toUint8Array();\n    }\n    toString() {\n      return this.key.toString();\n    }\n    serialize(e) {\n      e.serializeBytes(this.toUint8Array());\n    }\n    static deserialize(e) {\n      let t = e.deserializeBytes();\n      return new r(t);\n    }\n    static isPrivateKey(e) {\n      return e instanceof r;\n    }\n  };\nr.LENGTH = 32;\nvar v = r,\n  a = class a extends f {\n    constructor(e) {\n      super();\n      let t = s.fromHexInput(e);\n      if (t.toUint8Array().length !== a.LENGTH) throw new Error(`Signature length should be ${a.LENGTH}, received ${t.toUint8Array().length}`);\n      this.data = t;\n    }\n    toUint8Array() {\n      return this.data.toUint8Array();\n    }\n    serialize(e) {\n      e.serializeBytes(this.data.toUint8Array());\n    }\n    static deserialize(e) {\n      let t = e.deserializeBytes();\n      return new a(t);\n    }\n  };\na.LENGTH = 64;\nvar y = a;\nexport { m as a, v as b, y as c };\n//# sourceMappingURL=chunk-4VU2ABLU.mjs.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}