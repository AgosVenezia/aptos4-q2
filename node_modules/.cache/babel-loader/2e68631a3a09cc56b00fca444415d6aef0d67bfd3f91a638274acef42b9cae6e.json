{"ast":null,"code":"import { a as y, c as P, d as V, e as v } from \"./chunk-GMKKHGXK.mjs\";\nimport { a as B } from \"./chunk-ONBFUPEC.mjs\";\nimport { a as w, b as m } from \"./chunk-OAEDFM7T.mjs\";\nimport { b as I, d as U } from \"./chunk-P3J54CQG.mjs\";\nimport { a as d } from \"./chunk-IBLZ6MZU.mjs\";\nimport { b as C } from \"./chunk-4OV7QU2U.mjs\";\nimport { a as T } from \"./chunk-HBIDHQ2M.mjs\";\nimport { b } from \"./chunk-RNJHULIT.mjs\";\nimport { a as H } from \"./chunk-PRZ7AIGA.mjs\";\nimport { b as x } from \"./chunk-KM6UXNC7.mjs\";\nimport { a as G } from \"./chunk-N47FTRYO.mjs\";\nimport { a as u, b as E } from \"./chunk-QQIVWB6G.mjs\";\nimport { b as p } from \"./chunk-KFNDDPOW.mjs\";\nimport { jwtDecode as M } from \"jwt-decode\";\nvar me = 1e7,\n  R = 120,\n  k = 30,\n  F = 330,\n  ye = 120,\n  he = 350,\n  ge = 300,\n  fe = 93,\n  o = class o extends C {\n    constructor(e, t) {\n      super();\n      let i = p.fromHexInput(t).toUint8Array();\n      if (i.length !== o.ID_COMMITMENT_LENGTH) throw new Error(`Id Commitment length in bytes should be ${o.ID_COMMITMENT_LENGTH}`);\n      this.iss = e, this.idCommitment = i;\n    }\n    authKey() {\n      let e = new E();\n      return e.serializeU32AsUleb128(3), e.serializeFixedBytes(this.bcsToBytes()), H.fromSchemeAndBytes({\n        scheme: 2,\n        input: e.toUint8Array()\n      });\n    }\n    verifySignature(e) {\n      throw new Error(\"Not yet implemented\");\n    }\n    serialize(e) {\n      e.serializeStr(this.iss), e.serializeBytes(this.idCommitment);\n    }\n    static deserialize(e) {\n      let t = e.deserializeStr(),\n        i = e.deserializeBytes();\n      return new o(t, i);\n    }\n    static load(e) {\n      let t = e.deserializeStr(),\n        i = e.deserializeBytes();\n      return new o(t, i);\n    }\n    static isPublicKey(e) {\n      return e instanceof o;\n    }\n    static create(e) {\n      return _(e), new o(e.iss, _(e));\n    }\n    static fromJwtAndPepper(e) {\n      let {\n          jwt: t,\n          pepper: i,\n          uidKey: a = \"sub\"\n        } = e,\n        n = M(t);\n      if (typeof n.iss != \"string\") throw new Error(\"iss was not found\");\n      if (typeof n.aud != \"string\") throw new Error(\"aud was not found or an array of values\");\n      let s = n[a];\n      return o.create({\n        iss: n.iss,\n        uidKey: a,\n        uidVal: s,\n        aud: n.aud,\n        pepper: i\n      });\n    }\n    static isInstance(e) {\n      return \"iss\" in e && typeof e.iss == \"string\" && \"idCommitment\" in e && e.idCommitment instanceof Uint8Array;\n    }\n  };\no.ID_COMMITMENT_LENGTH = 32;\nvar z = o;\nfunction _(r) {\n  let {\n      uidKey: e,\n      uidVal: t,\n      aud: i,\n      pepper: a\n    } = r,\n    n = [P(p.fromHexInput(a).toUint8Array()), y(i, R), y(t, F), y(e, k)];\n  return V(v(n), z.ID_COMMITMENT_LENGTH);\n}\nvar D = class r extends d {\n    constructor(e) {\n      super();\n      let {\n        jwtHeader: t,\n        ephemeralCertificate: i,\n        expiryDateSecs: a,\n        ephemeralPublicKey: n,\n        ephemeralSignature: s\n      } = e;\n      this.jwtHeader = t, this.ephemeralCertificate = i, this.expiryDateSecs = a, this.ephemeralPublicKey = n, this.ephemeralSignature = s;\n    }\n    serialize(e) {\n      this.ephemeralCertificate.serialize(e), e.serializeStr(this.jwtHeader), e.serializeU64(this.expiryDateSecs), this.ephemeralPublicKey.serialize(e), this.ephemeralSignature.serialize(e);\n    }\n    static deserialize(e) {\n      let t = h.deserialize(e),\n        i = e.deserializeStr(),\n        a = e.deserializeU64(),\n        n = w.deserialize(e),\n        s = m.deserialize(e);\n      return new r({\n        jwtHeader: i,\n        expiryDateSecs: Number(a),\n        ephemeralCertificate: t,\n        ephemeralPublicKey: n,\n        ephemeralSignature: s\n      });\n    }\n    static getSimulationSignature() {\n      return new r({\n        jwtHeader: \"{}\",\n        ephemeralCertificate: new h(new S({\n          proof: new f(new g({\n            a: new Uint8Array(32),\n            b: new Uint8Array(64),\n            c: new Uint8Array(32)\n          }), 0),\n          expHorizonSecs: 0\n        }), 0),\n        expiryDateSecs: 0,\n        ephemeralPublicKey: new w(new I(new Uint8Array(32))),\n        ephemeralSignature: new m(new U(new Uint8Array(64)))\n      });\n    }\n    static isSignature(e) {\n      return e instanceof r;\n    }\n  },\n  h = class r extends d {\n    constructor(e, t) {\n      super(), this.signature = e, this.variant = t;\n    }\n    toUint8Array() {\n      return this.signature.toUint8Array();\n    }\n    serialize(e) {\n      e.serializeU32AsUleb128(this.variant), this.signature.serialize(e);\n    }\n    static deserialize(e) {\n      let t = e.deserializeUleb128AsU32();\n      switch (t) {\n        case 0:\n          return new r(S.deserialize(e), t);\n        default:\n          throw new Error(`Unknown variant index for EphemeralCertificate: ${t}`);\n      }\n    }\n  },\n  c = class r extends u {\n    constructor(e) {\n      if (super(), this.data = p.fromHexInput(e).toUint8Array(), this.data.length !== 32) throw new Error(\"Input needs to be 32 bytes\");\n    }\n    serialize(e) {\n      e.serializeFixedBytes(this.data);\n    }\n    static deserialize(e) {\n      let t = e.deserializeFixedBytes(32);\n      return new r(t);\n    }\n  },\n  l = class r extends u {\n    constructor(e) {\n      if (super(), this.data = p.fromHexInput(e).toUint8Array(), this.data.length !== 64) throw new Error(\"Input needs to be 64 bytes\");\n    }\n    serialize(e) {\n      e.serializeFixedBytes(this.data);\n    }\n    static deserialize(e) {\n      let t = e.deserializeFixedBytes(64);\n      return new r(t);\n    }\n  },\n  g = class r extends B {\n    constructor(e) {\n      super();\n      let {\n        a: t,\n        b: i,\n        c: a\n      } = e;\n      this.a = new c(t), this.b = new l(i), this.c = new c(a);\n    }\n    serialize(e) {\n      this.a.serialize(e), this.b.serialize(e), this.c.serialize(e);\n    }\n    static deserialize(e) {\n      let t = c.deserialize(e).bcsToBytes(),\n        i = l.deserialize(e).bcsToBytes(),\n        a = c.deserialize(e).bcsToBytes();\n      return new r({\n        a: t,\n        b: i,\n        c: a\n      });\n    }\n  },\n  f = class r extends u {\n    constructor(e, t) {\n      super(), this.proof = e, this.variant = t;\n    }\n    serialize(e) {\n      e.serializeU32AsUleb128(this.variant), this.proof.serialize(e);\n    }\n    static deserialize(e) {\n      let t = e.deserializeUleb128AsU32();\n      switch (t) {\n        case 0:\n          return new r(g.deserialize(e), t);\n        default:\n          throw new Error(`Unknown variant index for ZkProof: ${t}`);\n      }\n    }\n  },\n  S = class r extends d {\n    constructor(e) {\n      super();\n      let {\n        proof: t,\n        expHorizonSecs: i,\n        trainingWheelsSignature: a,\n        extraField: n,\n        overrideAudVal: s\n      } = e;\n      this.proof = t, this.expHorizonSecs = i, this.trainingWheelsSignature = a, this.extraField = n, this.overrideAudVal = s;\n    }\n    static fromBytes(e) {\n      return r.deserialize(new G(e));\n    }\n    serialize(e) {\n      this.proof.serialize(e), e.serializeU64(this.expHorizonSecs), e.serializeOptionStr(this.extraField), e.serializeOptionStr(this.overrideAudVal), e.serializeOption(this.trainingWheelsSignature);\n    }\n    static deserialize(e) {\n      let t = f.deserialize(e),\n        i = Number(e.deserializeU64()),\n        a = e.deserializeOptionStr(),\n        n = e.deserializeOptionStr(),\n        s = e.deserializeOption(m);\n      return new r({\n        proof: t,\n        expHorizonSecs: i,\n        trainingWheelsSignature: s,\n        extraField: a,\n        overrideAudVal: n\n      });\n    }\n  },\n  A = class r {\n    constructor(e, t) {\n      this.verficationKey = e, this.maxExpHorizonSecs = t;\n    }\n    static create(e, t) {\n      return new r(new K({\n        alphaG1: e.alpha_g1,\n        betaG2: e.beta_g2,\n        deltaG2: e.delta_g2,\n        gammaAbcG1: e.gamma_abc_g1,\n        gammaG2: e.gamma_g2\n      }), t);\n    }\n  },\n  K = class r {\n    constructor(e) {\n      let {\n        alphaG1: t,\n        betaG2: i,\n        deltaG2: a,\n        gammaAbcG1: n,\n        gammaG2: s\n      } = e;\n      this.alphaG1 = new c(t), this.betaG2 = new l(i), this.deltaG2 = new l(a), this.gammaAbcG1 = [new c(n[0]), new c(n[1])], this.gammaG2 = new l(s);\n    }\n    static fromGroth16VerificationKeyResponse(e) {\n      return new r({\n        alphaG1: e.alpha_g1,\n        betaG2: e.beta_g2,\n        deltaG2: e.delta_g2,\n        gammaAbcG1: e.gamma_abc_g1,\n        gammaG2: e.gamma_g2\n      });\n    }\n  };\nasync function Se(r) {\n  let {\n    aptosConfig: e\n  } = r;\n  return T(async () => {\n    let t = await L(r),\n      i = await N(r);\n    return A.create(i, Number(t.max_exp_horizon_secs));\n  }, `keyless-configuration-${e.network}`, 1e3 * 60 * 5)();\n}\nasync function L(r) {\n  let {\n      aptosConfig: e,\n      options: t\n    } = r,\n    i = \"0x1::keyless_account::Configuration\",\n    {\n      data: a\n    } = await b({\n      aptosConfig: e,\n      originMethod: \"getKeylessConfigurationResource\",\n      path: `accounts/${x.from(\"0x1\").toString()}/resource/${i}`,\n      params: {\n        ledger_version: t?.ledgerVersion\n      }\n    });\n  return a.data;\n}\nasync function N(r) {\n  let {\n      aptosConfig: e,\n      options: t\n    } = r,\n    i = \"0x1::keyless_account::Groth16VerificationKey\",\n    {\n      data: a\n    } = await b({\n      aptosConfig: e,\n      originMethod: \"getGroth16VerificationKeyResource\",\n      path: `accounts/${x.from(\"0x1\").toString()}/resource/${i}`,\n      params: {\n        ledger_version: t?.ledgerVersion\n      }\n    });\n  return a.data;\n}\nexport { me as a, R as b, k as c, F as d, ye as e, he as f, ge as g, fe as h, z as i, D as j, h as k, g as l, f as m, S as n, A as o, Se as p };\n//# sourceMappingURL=chunk-FTZGP6XW.mjs.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}