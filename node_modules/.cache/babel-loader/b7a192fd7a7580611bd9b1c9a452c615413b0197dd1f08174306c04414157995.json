{"ast":null,"code":"import { a as K } from \"./chunk-EE7GDBA5.mjs\";\nimport { c as d } from \"./chunk-BVVHGSWC.mjs\";\nimport { d as b, e as v, f as q, g as O, i as P, j as S, k as M, u as G } from \"./chunk-VHNX2NUR.mjs\";\nimport { a as f } from \"./chunk-3H5DGQKX.mjs\";\nimport { a as k } from \"./chunk-PCLU4KLY.mjs\";\nimport { a as T } from \"./chunk-TPJLAYW6.mjs\";\nimport { b as C } from \"./chunk-4VU2ABLU.mjs\";\nimport { c as _ } from \"./chunk-P3J54CQG.mjs\";\nimport { a as w } from \"./chunk-HBIDHQ2M.mjs\";\nimport { b as A, d as p } from \"./chunk-RNJHULIT.mjs\";\nimport { a as h } from \"./chunk-GQABU3RQ.mjs\";\nimport { e as y } from \"./chunk-J245N3XF.mjs\";\nimport { a as g } from \"./chunk-PRZ7AIGA.mjs\";\nimport { b as i } from \"./chunk-KM6UXNC7.mjs\";\nasync function R(o) {\n  let {\n      aptosConfig: n,\n      accountAddress: t\n    } = o,\n    {\n      data: e\n    } = await A({\n      aptosConfig: n,\n      originMethod: \"getInfo\",\n      path: `accounts/${i.from(t).toString()}`\n    });\n  return e;\n}\nasync function Y(o) {\n  let {\n    aptosConfig: n,\n    accountAddress: t,\n    options: e\n  } = o;\n  return p({\n    aptosConfig: n,\n    originMethod: \"getModules\",\n    path: `accounts/${i.from(t).toString()}/modules`,\n    params: {\n      ledger_version: e?.ledgerVersion,\n      start: e?.offset,\n      limit: e?.limit ?? 1e3\n    }\n  });\n}\nasync function Z(o) {\n  return o.options?.ledgerVersion !== void 0 ? Q(o) : w(async () => Q(o), `module-${o.accountAddress}-${o.moduleName}`, 1e3 * 60 * 5)();\n}\nasync function Q(o) {\n  let {\n      aptosConfig: n,\n      accountAddress: t,\n      moduleName: e,\n      options: r\n    } = o,\n    {\n      data: s\n    } = await A({\n      aptosConfig: n,\n      originMethod: \"getModule\",\n      path: `accounts/${i.from(t).toString()}/module/${e}`,\n      params: {\n        ledger_version: r?.ledgerVersion\n      }\n    });\n  return s;\n}\nasync function ee(o) {\n  let {\n    aptosConfig: n,\n    accountAddress: t,\n    options: e\n  } = o;\n  return p({\n    aptosConfig: n,\n    originMethod: \"getTransactions\",\n    path: `accounts/${i.from(t).toString()}/transactions`,\n    params: {\n      start: e?.offset,\n      limit: e?.limit\n    }\n  });\n}\nasync function oe(o) {\n  let {\n    aptosConfig: n,\n    accountAddress: t,\n    options: e\n  } = o;\n  return p({\n    aptosConfig: n,\n    originMethod: \"getResources\",\n    path: `accounts/${i.from(t).toString()}/resources`,\n    params: {\n      ledger_version: e?.ledgerVersion,\n      start: e?.offset,\n      limit: e?.limit ?? 999\n    }\n  });\n}\nasync function x(o) {\n  let {\n      aptosConfig: n,\n      accountAddress: t,\n      resourceType: e,\n      options: r\n    } = o,\n    {\n      data: s\n    } = await A({\n      aptosConfig: n,\n      originMethod: \"getResource\",\n      path: `accounts/${i.from(t).toString()}/resource/${e}`,\n      params: {\n        ledger_version: r?.ledgerVersion\n      }\n    });\n  return s.data;\n}\nasync function L(o) {\n  let {\n      aptosConfig: n,\n      authenticationKey: t,\n      options: e\n    } = o,\n    r = await x({\n      aptosConfig: n,\n      accountAddress: \"0x1\",\n      resourceType: \"0x1::account::OriginatingAddress\",\n      options: e\n    }),\n    {\n      address_map: {\n        handle: s\n      }\n    } = r,\n    c = i.from(t);\n  try {\n    let a = await K({\n      aptosConfig: n,\n      handle: s,\n      data: {\n        key: c.toString(),\n        key_type: \"address\",\n        value_type: \"address\"\n      },\n      options: e\n    });\n    return i.from(a);\n  } catch (a) {\n    if (a instanceof h && a.data.error_code === \"table_item_not_found\") return c;\n    throw a;\n  }\n}\nasync function te(o) {\n  let {\n      aptosConfig: n,\n      accountAddress: t\n    } = o,\n    r = {\n      owner_address: {\n        _eq: i.from(t).toStringLong()\n      },\n      amount: {\n        _gt: 0\n      }\n    },\n    c = await d({\n      aptosConfig: n,\n      query: {\n        query: S,\n        variables: {\n          where_condition: r\n        }\n      },\n      originMethod: \"getAccountTokensCount\"\n    });\n  return c.current_token_ownerships_v2_aggregate.aggregate ? c.current_token_ownerships_v2_aggregate.aggregate.count : 0;\n}\nasync function ne(o) {\n  let {\n      aptosConfig: n,\n      accountAddress: t,\n      options: e\n    } = o,\n    s = {\n      owner_address: {\n        _eq: i.from(t).toStringLong()\n      },\n      amount: {\n        _gt: 0\n      }\n    };\n  e?.tokenStandard && (s.token_standard = {\n    _eq: e?.tokenStandard\n  });\n  let c = {\n    query: O,\n    variables: {\n      where_condition: s,\n      offset: e?.offset,\n      limit: e?.limit,\n      order_by: e?.orderBy\n    }\n  };\n  return (await d({\n    aptosConfig: n,\n    query: c,\n    originMethod: \"getAccountOwnedTokens\"\n  })).current_token_ownerships_v2;\n}\nasync function re(o) {\n  let {\n      aptosConfig: n,\n      accountAddress: t,\n      collectionAddress: e,\n      options: r\n    } = o,\n    s = i.from(t).toStringLong(),\n    c = i.from(e).toStringLong(),\n    a = {\n      owner_address: {\n        _eq: s\n      },\n      current_token_data: {\n        collection_id: {\n          _eq: c\n        }\n      },\n      amount: {\n        _gt: 0\n      }\n    };\n  r?.tokenStandard && (a.token_standard = {\n    _eq: r?.tokenStandard\n  });\n  let u = {\n    query: P,\n    variables: {\n      where_condition: a,\n      offset: r?.offset,\n      limit: r?.limit,\n      order_by: r?.orderBy\n    }\n  };\n  return (await d({\n    aptosConfig: n,\n    query: u,\n    originMethod: \"getAccountOwnedTokensFromCollectionAddress\"\n  })).current_token_ownerships_v2;\n}\nasync function se(o) {\n  let {\n      aptosConfig: n,\n      accountAddress: t,\n      options: e\n    } = o,\n    s = {\n      owner_address: {\n        _eq: i.from(t).toStringLong()\n      }\n    };\n  e?.tokenStandard && (s.current_collection = {\n    token_standard: {\n      _eq: e?.tokenStandard\n    }\n  });\n  let c = {\n    query: q,\n    variables: {\n      where_condition: s,\n      offset: e?.offset,\n      limit: e?.limit,\n      order_by: e?.orderBy\n    }\n  };\n  return (await d({\n    aptosConfig: n,\n    query: c,\n    originMethod: \"getAccountCollectionsWithOwnedTokens\"\n  })).current_collection_ownership_v2_view;\n}\nasync function ce(o) {\n  let {\n      aptosConfig: n,\n      accountAddress: t\n    } = o,\n    e = i.from(t).toStringLong(),\n    s = await d({\n      aptosConfig: n,\n      query: {\n        query: M,\n        variables: {\n          address: e\n        }\n      },\n      originMethod: \"getAccountTransactionsCount\"\n    });\n  return s.account_transactions_aggregate.aggregate ? s.account_transactions_aggregate.aggregate.count : 0;\n}\nasync function ie(o) {\n  let {\n      aptosConfig: n,\n      accountAddress: t,\n      coinType: e,\n      faMetadataAddress: r\n    } = o,\n    s = e,\n    c;\n  if (e !== void 0 && r !== void 0) c = i.from(r).toStringLong();else if (e !== void 0 && r === void 0) e === y ? c = i.A.toStringLong() : c = k(i.A, e).toStringLong();else if (e === void 0 && r !== void 0) {\n    let m = i.from(r);\n    c = m.toStringLong(), m === i.A && (s = y);\n  } else throw new Error(\"Either coinType, fungibleAssetAddress, or both must be provided\");\n  let a = i.from(t).toStringLong(),\n    u = {\n      asset_type: {\n        _eq: c\n      }\n    };\n  s !== void 0 && (u = {\n    asset_type: {\n      _in: [s, c]\n    }\n  });\n  let l = await B({\n    aptosConfig: n,\n    accountAddress: a,\n    options: {\n      where: u\n    }\n  });\n  return l[0] ? l[0].amount : 0;\n}\nasync function B(o) {\n  let {\n      aptosConfig: n,\n      accountAddress: t,\n      options: e\n    } = o,\n    r = i.from(t).toStringLong(),\n    s = {\n      ...e?.where,\n      owner_address: {\n        _eq: r\n      }\n    },\n    c = {\n      query: v,\n      variables: {\n        where_condition: s,\n        offset: e?.offset,\n        limit: e?.limit,\n        order_by: e?.orderBy\n      }\n    };\n  return (await d({\n    aptosConfig: n,\n    query: c,\n    originMethod: \"getAccountCoinsData\"\n  })).current_fungible_asset_balances;\n}\nasync function ae(o) {\n  let {\n      aptosConfig: n,\n      accountAddress: t\n    } = o,\n    e = i.from(t).toStringLong(),\n    s = await d({\n      aptosConfig: n,\n      query: {\n        query: b,\n        variables: {\n          address: e\n        }\n      },\n      originMethod: \"getAccountCoinsCount\"\n    });\n  if (!s.current_fungible_asset_balances_aggregate.aggregate) throw Error(\"Failed to get the count of account coins\");\n  return s.current_fungible_asset_balances_aggregate.aggregate.count;\n}\nasync function de(o) {\n  let {\n      aptosConfig: n,\n      accountAddress: t,\n      options: e\n    } = o,\n    s = {\n      owner_address: {\n        _eq: i.from(t).toStringLong()\n      }\n    },\n    c = {\n      query: G,\n      variables: {\n        where_condition: s,\n        offset: e?.offset,\n        limit: e?.limit,\n        order_by: e?.orderBy\n      }\n    };\n  return (await d({\n    aptosConfig: n,\n    query: c,\n    originMethod: \"getAccountOwnedObjects\"\n  })).current_objects;\n}\nasync function ue(o) {\n  let {\n      aptosConfig: n,\n      privateKey: t\n    } = o,\n    e = new T(t.publicKey());\n  if (t instanceof C) {\n    let s = g.fromPublicKey({\n      publicKey: e\n    }).derivedAddress();\n    return f.fromPrivateKey({\n      privateKey: t,\n      address: s\n    });\n  }\n  if (t instanceof _) {\n    let r = g.fromPublicKey({\n      publicKey: e\n    });\n    if (await I({\n      authKey: r,\n      aptosConfig: n\n    })) {\n      let u = r.derivedAddress();\n      return f.fromPrivateKey({\n        privateKey: t,\n        address: u,\n        legacy: !1\n      });\n    }\n    let c = g.fromPublicKey({\n      publicKey: e.publicKey\n    });\n    if (await I({\n      authKey: c,\n      aptosConfig: n\n    })) {\n      let u = c.derivedAddress();\n      return f.fromPrivateKey({\n        privateKey: t,\n        address: u,\n        legacy: !0\n      });\n    }\n  }\n  throw new Error(`Can't derive account from private key ${t}`);\n}\nasync function I(o) {\n  let {\n      aptosConfig: n,\n      authKey: t\n    } = o,\n    e = await L({\n      aptosConfig: n,\n      authenticationKey: t.derivedAddress()\n    });\n  try {\n    return await R({\n      aptosConfig: n,\n      accountAddress: e\n    }), !0;\n  } catch (r) {\n    if (r.status === 404) return !1;\n    throw new Error(`Error while looking for an account info ${e.toString()}`);\n  }\n}\nexport { R as a, Y as b, Z as c, ee as d, oe as e, x as f, L as g, te as h, ne as i, re as j, se as k, ce as l, ie as m, B as n, ae as o, de as p, ue as q, I as r };\n//# sourceMappingURL=chunk-Y267I7DC.mjs.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}