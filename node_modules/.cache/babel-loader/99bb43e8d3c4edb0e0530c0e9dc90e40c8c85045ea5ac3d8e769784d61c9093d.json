{"ast":null,"code":"import { a as m } from \"./chunk-CDQGPCHU.mjs\";\nimport { e as a } from \"./chunk-MK2QAHXC.mjs\";\nimport { a as l, b as o } from \"./chunk-6DMDYBV6.mjs\";\nimport { b as y } from \"./chunk-KM6UXNC7.mjs\";\nvar p = class g {\n  constructor(i) {\n    let {\n      multiKey: t,\n      signers: e,\n      address: c\n    } = i;\n    this.publicKey = t, this.signingScheme = 3, this.accountAddress = c ? y.from(c) : this.publicKey.authKey().derivedAddress();\n    let s = [];\n    for (let n of e) s.push(this.publicKey.getIndex(n.publicKey));\n    let r = e.map((n, u) => [n, s[u]]);\n    r.sort((n, u) => n[1] - u[1]), this.signers = r.map(n => n[0]), this.signerIndicies = r.map(n => n[1]), this.signaturesBitmap = this.publicKey.createBitmap({\n      bits: s\n    });\n  }\n  static fromPublicKeysAndSigners(i) {\n    let {\n        publicKeys: t,\n        signaturesRequired: e,\n        signers: c\n      } = i,\n      s = new l({\n        publicKeys: t,\n        signaturesRequired: e\n      });\n    return new g({\n      multiKey: s,\n      signers: c\n    });\n  }\n  static isMultiKeySigner(i) {\n    return i instanceof g;\n  }\n  signWithAuthenticator(i) {\n    return new a(this.publicKey, this.sign(i));\n  }\n  signTransactionWithAuthenticator(i) {\n    return new a(this.publicKey, this.signTransaction(i));\n  }\n  async waitForProofFetch() {\n    let t = this.signers.filter(e => e instanceof m).map(async e => e.waitForProofFetch());\n    await Promise.all(t);\n  }\n  sign(i) {\n    let t = [];\n    for (let e of this.signers) t.push(e.sign(i));\n    return new o({\n      signatures: t,\n      bitmap: this.signaturesBitmap\n    });\n  }\n  signTransaction(i) {\n    let t = [];\n    for (let e of this.signers) t.push(e.signTransaction(i));\n    return new o({\n      signatures: t,\n      bitmap: this.signaturesBitmap\n    });\n  }\n  verifySignature(i) {\n    let {\n      message: t,\n      signature: e\n    } = i;\n    if (!this.signerIndicies.every((s, r) => r === 0 || s >= this.signerIndicies[r - 1])) return !1;\n    for (let s = 0; s < e.signatures.length; s += 1) {\n      let r = e.signatures[s];\n      if (!this.publicKey.publicKeys[this.signerIndicies[s]].verifySignature({\n        message: t,\n        signature: r\n      })) return !1;\n    }\n    return !0;\n  }\n};\nexport { p as a };\n//# sourceMappingURL=chunk-5SGSPCOY.mjs.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}