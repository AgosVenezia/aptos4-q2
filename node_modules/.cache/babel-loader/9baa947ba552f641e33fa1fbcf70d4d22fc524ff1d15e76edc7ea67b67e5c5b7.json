{"ast":null,"code":"// src/index.ts\nimport { ConnectRequest, ConnectResponse as ConnectResponse2, DisconnectRequest, DisconnectResponse, GetConnectedAccountsRequest, GetConnectedAccountsResponse, IsConnectedRequest, IsConnectedResponse, SignAndSubmitTransactionRequest, SignMessageRequest, SignTransactionRequest, urlEncodeWalletRequest } from \"@aptos-connect/wallet-api\";\n\n// src/prompt.ts\nimport { ConnectResponse, isTypedMessage, PromptApprovalResponseMessage, PromptOpenerPingRequestMessage, PromptOpenerPingResponseMessage, PromptUnauthorizedErrorMessage } from \"@aptos-connect/wallet-api\";\nvar DEFAULT_PROMPT_SIZE = {\n  height: 695,\n  width: 465\n};\nvar PROMPT_POLLER_INTERVAL = 500;\nvar dismissalSerializedResponse = ConnectResponse.serialize({\n  status: \"dismissed\"\n});\nvar PromptUnauthorizedError = class extends Error {\n  constructor() {\n    super(\"Unauthorized\");\n  }\n};\nfunction openPrompt(url, size = DEFAULT_PROMPT_SIZE) {\n  const {\n    height,\n    width\n  } = size;\n  const options = {\n    height,\n    left: window.screenLeft + Math.round((window.outerWidth - width) / 2),\n    popup: true,\n    top: window.screenTop + Math.round((window.outerHeight - height) / 2),\n    width\n  };\n  const strOptions = Object.entries(options).map(([key, value]) => `${key}=${JSON.stringify(value)}`).reduce((acc, entry) => `${acc}, ${entry}`);\n  const href = url instanceof URL ? url.href : url;\n  const promptWindow = window.open(href, void 0, strOptions);\n  if (promptWindow === null) {\n    throw new Error(\"Couldn't open prompt\");\n  }\n  return promptWindow;\n}\nasync function waitForPromptResponse(baseUrl, promptWindow) {\n  return new Promise((resolve, reject) => {\n    const listeners = {\n      onMessage: message => {\n        if (message.source !== promptWindow || message.origin !== baseUrl) {\n          return;\n        }\n        if (isTypedMessage(PromptUnauthorizedErrorMessage, message.data)) {\n          window.removeEventListener(\"message\", listeners.onMessage);\n          clearTimeout(listeners.promptPollerId);\n          reject(new PromptUnauthorizedError());\n          return;\n        }\n        if (isTypedMessage(PromptOpenerPingRequestMessage, message.data)) {\n          promptWindow.postMessage(new PromptOpenerPingResponseMessage(), baseUrl);\n          return;\n        }\n        if (isTypedMessage(PromptApprovalResponseMessage, message.data)) {\n          window.removeEventListener(\"message\", listeners.onMessage);\n          clearTimeout(listeners.promptPollerId);\n          resolve(message.data.serializedValue);\n        }\n      },\n      promptPollerId: setInterval(() => {\n        if (promptWindow.closed) {\n          window.removeEventListener(\"message\", listeners.onMessage);\n          clearTimeout(listeners.promptPollerId);\n          resolve(dismissalSerializedResponse);\n        }\n      }, PROMPT_POLLER_INTERVAL)\n    };\n    window.addEventListener(\"message\", listeners.onMessage);\n  });\n}\n\n// src/state.ts\nimport { base64ToBytes, bytesToBase64, deserializeAccountInfo, serializeAccountInfo } from \"@aptos-connect/wallet-api\";\nimport { Deserializer, Serializer } from \"@aptos-labs/ts-sdk\";\nvar localDappStateKey = \"@aptos-connect/dapp-local-state\";\nfunction serializeLocalDappState(state) {\n  const serializer = new Serializer();\n  serializer.serializeU32AsUleb128(state.connectedAccounts.length);\n  for (const account of state.connectedAccounts) {\n    serializeAccountInfo(serializer, account);\n  }\n  return serializer.toUint8Array();\n}\nfunction deserializeLocalDappState(serializedValue) {\n  const deserializer = new Deserializer(serializedValue);\n  const connectedAccountsLength = deserializer.deserializeUleb128AsU32();\n  const connectedAccounts = [];\n  for (let i = 0; i < connectedAccountsLength; i += 1) {\n    connectedAccounts.push(deserializeAccountInfo(deserializer));\n  }\n  return {\n    connectedAccounts\n  };\n}\nfunction getState() {\n  const encodedValue = window.localStorage.getItem(localDappStateKey);\n  return encodedValue ? deserializeLocalDappState(base64ToBytes(encodedValue)) : {\n    connectedAccounts: []\n  };\n}\nfunction setState(state) {\n  const serializedValue = serializeLocalDappState(state);\n  const encodedValue = bytesToBase64(serializedValue);\n  window.localStorage.setItem(localDappStateKey, encodedValue);\n}\nfunction getConnectedAccounts() {\n  const state = getState();\n  return state.connectedAccounts;\n}\nfunction addConnectedAccount(account) {\n  const {\n    connectedAccounts,\n    ...state\n  } = getState();\n  connectedAccounts.push(account);\n  setState({\n    ...state,\n    connectedAccounts\n  });\n}\nfunction removeConnectedAccount(address) {\n  const {\n    connectedAccounts,\n    ...state\n  } = getState();\n  const index = connectedAccounts.findIndex(a => a.address.equals(address));\n  if (index >= 0) {\n    connectedAccounts.splice(index, 1);\n  }\n  setState({\n    ...state,\n    connectedAccounts\n  });\n}\n\n// src/telegram/openTelegramPrompt.ts\nimport { encodePopupWalletRequest, makePopupWalletRequestChallenge } from \"@aptos-connect/wallet-api\";\nimport { postEvent as postTelegramEvent } from \"@telegram-apps/bridge\";\nimport { v4 as randomUUID } from \"uuid\";\n\n// src/telegram/createWalletRequest.ts\nimport { bytesToBase64 as bytesToBase642, bytesToBase64url, encodeWalletRequestBody } from \"@aptos-connect/wallet-api\";\nasync function createWalletRequest(baseUrl, request) {\n  const encodedClientIdentityKey = bytesToBase64url(request.clientIdentityKey.toUint8Array());\n  const response = await fetch(`${baseUrl}/v1/dapp/clients/${encodedClientIdentityKey}/requests/`, {\n    body: JSON.stringify({\n      body: encodeWalletRequestBody(request.body),\n      id: request.id,\n      signature: bytesToBase642(request.signature.toUint8Array()),\n      timestamp: request.timestamp\n    }),\n    headers: {\n      Accept: \"application/json\",\n      \"Content-Type\": \"application/json\"\n    },\n    method: \"post\"\n  });\n  if (!response.ok) {\n    throw new Error(\"Failed creating the wallet request\");\n  }\n}\n\n// src/telegram/getClientIdentityKey.ts\nimport { Ed25519PrivateKey } from \"@aptos-labs/ts-sdk\";\nvar identityKeyStorageKey = \"@aptos-connect/client-identity-key\";\nfunction getClientIdentityKey() {\n  const serialized = window.localStorage.getItem(identityKeyStorageKey);\n  if (serialized) {\n    return new Ed25519PrivateKey(serialized);\n  }\n  const identityKey = Ed25519PrivateKey.generate();\n  window.localStorage.setItem(identityKeyStorageKey, identityKey.toString());\n  return identityKey;\n}\n\n// src/telegram/getWalletResponse.ts\nimport { base64ToBytes as base64ToBytes2, bytesToBase64url as bytesToBase64url2 } from \"@aptos-connect/wallet-api\";\n\n// src/telegram/smartPolling.ts\nvar ON_RESUME_DELAY = 300;\nvar FG_RESPONSE_POLLING_INTERVAL = 2e3;\nvar BG_RESPONSE_POLLING_INTERVAL = 3e3;\nvar POLLING_TIMEOUT = 5 * 6e4;\nfunction waitFor(milliseconds) {\n  let timeoutId;\n  let cancel = () => {};\n  const timer = new Promise(resolve => {\n    timeoutId = setTimeout(resolve, milliseconds);\n    cancel = () => {\n      clearTimeout(timeoutId);\n      resolve();\n    };\n  });\n  timer.cancel = cancel;\n  return timer;\n}\nasync function smartPolling(callback) {\n  let timer;\n  let justResumed = false;\n  let pollingInterval = BG_RESPONSE_POLLING_INTERVAL;\n  const onWindowFocus = () => {\n    justResumed = true;\n    pollingInterval = FG_RESPONSE_POLLING_INTERVAL;\n    timer?.cancel();\n  };\n  const onWindowBlur = () => {\n    pollingInterval = BG_RESPONSE_POLLING_INTERVAL;\n  };\n  window.addEventListener(\"focus\", onWindowFocus);\n  window.addEventListener(\"blur\", onWindowBlur);\n  try {\n    const startTime = Date.now();\n    while (Date.now() - startTime < POLLING_TIMEOUT) {\n      timer = waitFor(pollingInterval);\n      await timer;\n      if (justResumed) {\n        timer = waitFor(ON_RESUME_DELAY);\n        await timer;\n      }\n      const response = await callback();\n      if (response.status === 200) {\n        return response;\n      }\n      justResumed = false;\n    }\n    throw new Error(\"Timeout\");\n  } finally {\n    window.removeEventListener(\"focus\", onWindowFocus);\n    window.removeEventListener(\"blur\", onWindowFocus);\n  }\n}\n\n// src/telegram/getWalletResponse.ts\nasync function getWalletResponse(baseUrl, clientIdentityKey, requestId) {\n  const encodedClientIdentityKey = bytesToBase64url2(clientIdentityKey.toUint8Array());\n  const url = new URL(`${baseUrl}/v1/dapp/clients/${encodedClientIdentityKey}/requests/${requestId}/response/`);\n  const response = await smartPolling(() => fetch(url, {\n    headers: {\n      Accept: \"application/json\"\n    },\n    method: \"get\"\n  }));\n  const responseBody = await response.json();\n  const data = base64ToBytes2(responseBody.data.body);\n  return {\n    data\n  };\n}\n\n// src/telegram/openTelegramPrompt.ts\nasync function openTelegramPrompt(baseUrl, request) {\n  const identityKey = getClientIdentityKey();\n  const clientIdentityKey = identityKey.publicKey();\n  const requestId = randomUUID();\n  const timestamp = Date.now();\n  const challenge = makePopupWalletRequestChallenge({\n    body: request,\n    id: requestId,\n    timestamp\n  });\n  const signature = identityKey.sign(challenge);\n  const signedWalletRequest = {\n    body: request,\n    clientIdentityKey,\n    id: requestId,\n    signature,\n    timestamp\n  };\n  let encodedRequest = encodePopupWalletRequest(signedWalletRequest);\n  if (encodedRequest.length > 1024) {\n    void createWalletRequest(baseUrl, signedWalletRequest);\n    encodedRequest = encodePopupWalletRequest({\n      clientIdentityKey,\n      id: requestId,\n      signature,\n      timestamp\n    });\n  }\n  postTelegramEvent(\"web_app_open_tg_link\", {\n    path_full: `/AptosConnectBot/AptosConnect?startapp=${encodedRequest}`\n  });\n  return getWalletResponse(baseUrl, clientIdentityKey, requestId);\n}\n\n// src/telegram/index.ts\nfunction isTelegramMiniApp() {\n  return window.TelegramWebviewProxy !== void 0;\n}\n\n// src/index.ts\nvar WebWalletTransport = class {\n  constructor(baseUrl, provider = \"google\") {\n    this.baseUrl = baseUrl;\n    this.provider = provider;\n    this.baseUrl = baseUrl;\n  }\n  async sendPromptRequest(request) {\n    if (isTelegramMiniApp()) {\n      return openTelegramPrompt(this.baseUrl, request);\n    }\n    const url = new URL(`${this.baseUrl}/prompt/`);\n    url.searchParams.set(\"request\", urlEncodeWalletRequest(request));\n    url.searchParams.set(\"provider\", this.provider);\n    const prompt = openPrompt(url);\n    return waitForPromptResponse(this.baseUrl, prompt);\n  }\n  async sendRequest(request) {\n    switch (request.name) {\n      case IsConnectedRequest.name:\n        {\n          const connectedAccounts = getConnectedAccounts();\n          return IsConnectedResponse.serialize(connectedAccounts.length > 0);\n        }\n      case GetConnectedAccountsRequest.name:\n        {\n          const connectedAccounts = getConnectedAccounts();\n          return GetConnectedAccountsResponse.serialize(connectedAccounts);\n        }\n      case ConnectRequest.name:\n        {\n          const serializedResponse = await this.sendPromptRequest(request);\n          const response = ConnectResponse2.deserialize(serializedResponse);\n          if (response.args.status === \"approved\") {\n            const {\n              account,\n              pairing\n            } = response.args.args;\n            if (pairing === void 0) {\n              addConnectedAccount(account);\n            }\n          }\n          return serializedResponse;\n        }\n      case DisconnectRequest.name:\n        {\n          const [activeAccount] = getConnectedAccounts();\n          if (activeAccount) {\n            removeConnectedAccount(activeAccount.address);\n          }\n          return DisconnectResponse.serialize({});\n        }\n      case SignMessageRequest.name:\n      case SignTransactionRequest.name:\n      case SignAndSubmitTransactionRequest.name:\n        {\n          return this.sendPromptRequest(request);\n        }\n      default:\n        {\n          throw new Error(\"Unexpected request\");\n        }\n    }\n  }\n};\nexport { WebWalletTransport };\n//# sourceMappingURL=index.mjs.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}