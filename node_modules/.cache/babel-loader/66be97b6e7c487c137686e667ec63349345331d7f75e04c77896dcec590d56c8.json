{"ast":null,"code":"import { callOrIdentity, HeadersInitToPlainObject } from '../../lib/prelude.js';\nimport { parseBatchRequestArgs } from '../functions/batchRequests.js';\nimport { parseRawRequestArgs } from '../functions/rawRequest.js';\nimport { parseRequestArgs } from '../functions/request.js';\nimport { analyzeDocument } from '../helpers/analyzeDocument.js';\nimport { runRequest } from '../helpers/runRequest.js';\n/**\n * GraphQL Client.\n */\nexport class GraphQLClient {\n  url;\n  requestConfig;\n  constructor(url, requestConfig = {}) {\n    this.url = url;\n    this.requestConfig = requestConfig;\n  }\n  /**\n   * Send a GraphQL query to the server.\n   */\n  rawRequest = async (...args) => {\n    const [queryOrOptions, variables, requestHeaders] = args;\n    const rawRequestOptions = parseRawRequestArgs(queryOrOptions, variables, requestHeaders);\n    const {\n      headers,\n      fetch = globalThis.fetch,\n      method = `POST`,\n      requestMiddleware,\n      responseMiddleware,\n      excludeOperationName,\n      ...fetchOptions\n    } = this.requestConfig;\n    const {\n      url\n    } = this;\n    if (rawRequestOptions.signal !== undefined) {\n      fetchOptions.signal = rawRequestOptions.signal;\n    }\n    const document = analyzeDocument(rawRequestOptions.query, excludeOperationName);\n    const response = await runRequest({\n      url,\n      request: {\n        _tag: `Single`,\n        document,\n        variables: rawRequestOptions.variables\n      },\n      headers: {\n        ...HeadersInitToPlainObject(callOrIdentity(headers)),\n        ...HeadersInitToPlainObject(rawRequestOptions.requestHeaders)\n      },\n      fetch,\n      method,\n      fetchOptions,\n      middleware: requestMiddleware\n    });\n    if (responseMiddleware) {\n      await responseMiddleware(response, {\n        operationName: document.operationName,\n        variables,\n        url: this.url\n      });\n    }\n    if (response instanceof Error) {\n      throw response;\n    }\n    return response;\n  };\n  async request(documentOrOptions, ...variablesAndRequestHeaders) {\n    const [variables, requestHeaders] = variablesAndRequestHeaders;\n    const requestOptions = parseRequestArgs(documentOrOptions, variables, requestHeaders);\n    const {\n      headers,\n      fetch = globalThis.fetch,\n      method = `POST`,\n      requestMiddleware,\n      responseMiddleware,\n      excludeOperationName,\n      ...fetchOptions\n    } = this.requestConfig;\n    const {\n      url\n    } = this;\n    if (requestOptions.signal !== undefined) {\n      fetchOptions.signal = requestOptions.signal;\n    }\n    const analyzedDocument = analyzeDocument(requestOptions.document, excludeOperationName);\n    const response = await runRequest({\n      url,\n      request: {\n        _tag: `Single`,\n        document: analyzedDocument,\n        variables: requestOptions.variables\n      },\n      headers: {\n        ...HeadersInitToPlainObject(callOrIdentity(headers)),\n        ...HeadersInitToPlainObject(requestOptions.requestHeaders)\n      },\n      fetch,\n      method,\n      fetchOptions,\n      middleware: requestMiddleware\n    });\n    if (responseMiddleware) {\n      await responseMiddleware(response, {\n        operationName: analyzedDocument.operationName,\n        variables: requestOptions.variables,\n        url: this.url\n      });\n    }\n    if (response instanceof Error) {\n      throw response;\n    }\n    return response.data;\n  }\n  async batchRequests(documentsOrOptions, requestHeaders) {\n    const batchRequestOptions = parseBatchRequestArgs(documentsOrOptions, requestHeaders);\n    const {\n      headers,\n      excludeOperationName,\n      ...fetchOptions\n    } = this.requestConfig;\n    if (batchRequestOptions.signal !== undefined) {\n      fetchOptions.signal = batchRequestOptions.signal;\n    }\n    const analyzedDocuments = batchRequestOptions.documents.map(({\n      document\n    }) => analyzeDocument(document, excludeOperationName));\n    const expressions = analyzedDocuments.map(({\n      expression\n    }) => expression);\n    const hasMutations = analyzedDocuments.some(({\n      isMutation\n    }) => isMutation);\n    const variables = batchRequestOptions.documents.map(({\n      variables\n    }) => variables);\n    const response = await runRequest({\n      url: this.url,\n      request: {\n        _tag: `Batch`,\n        operationName: undefined,\n        query: expressions,\n        hasMutations,\n        variables\n      },\n      headers: {\n        ...HeadersInitToPlainObject(callOrIdentity(headers)),\n        ...HeadersInitToPlainObject(batchRequestOptions.requestHeaders)\n      },\n      fetch: this.requestConfig.fetch ?? globalThis.fetch,\n      method: this.requestConfig.method || `POST`,\n      fetchOptions,\n      middleware: this.requestConfig.requestMiddleware\n    });\n    if (this.requestConfig.responseMiddleware) {\n      await this.requestConfig.responseMiddleware(response, {\n        operationName: undefined,\n        variables,\n        url: this.url\n      });\n    }\n    if (response instanceof Error) {\n      throw response;\n    }\n    return response.data;\n  }\n  setHeaders(headers) {\n    this.requestConfig.headers = headers;\n    return this;\n  }\n  /**\n   * Attach a header to the client. All subsequent requests will have this header.\n   */\n  setHeader(key, value) {\n    const {\n      headers\n    } = this.requestConfig;\n    if (headers) {\n      // todo what if headers is in nested array form... ?\n      // @ts-expect-error todo\n      headers[key] = value;\n    } else {\n      this.requestConfig.headers = {\n        [key]: value\n      };\n    }\n    return this;\n  }\n  /**\n   * Change the client endpoint. All subsequent requests will send to this endpoint.\n   */\n  setEndpoint(value) {\n    this.url = value;\n    return this;\n  }\n}\n//# sourceMappingURL=GraphQLClient.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}