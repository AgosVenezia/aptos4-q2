{"ast":null,"code":"let v = class H extends Error {\n  constructor(t, n, r) {\n    super(typeof n == \"object\" ? n.message : n || t, {\n      cause: typeof n == \"object\" ? n.cause : r\n    }), this.type = t, Object.setPrototypeOf(this, H.prototype);\n  }\n};\nfunction G(e) {\n  return e.replace(/[A-Z]/g, t => `_${t.toLowerCase()}`);\n}\nfunction we(e) {\n  return e.replace(/_[a-z]/g, t => t[1].toUpperCase());\n}\nconst he = \"ERR_INVALID_VALUE\",\n  de = \"ERR_UNEXPECTED_VALUE\",\n  me = \"ERR_UNEXPECTED_TYPE\",\n  K = \"ERR_PARSE\";\nfunction V(e, t) {\n  const n = {};\n  for (const r in e) {\n    const o = e[r];\n    if (!o) continue;\n    let s, a;\n    typeof o == \"function\" ? (s = r, a = o) : [s, a] = o;\n    try {\n      const i = a(t(s));\n      i !== void 0 && (n[r] = i);\n    } catch (i) {\n      throw new v(K, `Parser for \"${r}\" property failed${s === r ? \"\" : `. Source field: \"${s}\"`}`, i);\n    }\n  }\n  return n;\n}\nfunction Z(e) {\n  let t = e;\n  if (typeof t == \"string\") try {\n    t = JSON.parse(t);\n  } catch (n) {\n    throw new v(he, {\n      cause: n\n    });\n  }\n  if (typeof t != \"object\" || !t || Array.isArray(t)) throw new v(de);\n  return t;\n}\nfunction g(e, t) {\n  return n => {\n    const r = o => {\n      if (!(n && o === void 0)) try {\n        return t(o);\n      } catch (s) {\n        throw new v(K, {\n          message: `\"${e}\" transformer failed to parse the value`,\n          cause: s\n        });\n      }\n    };\n    return /* @__PURE__ */Object.assign(r, {\n      isValid(o) {\n        try {\n          return r(o), !0;\n        } catch {\n          return !1;\n        }\n      }\n    });\n  };\n}\nfunction l(e, t) {\n  return g(t || \"object\", n => {\n    const r = Z(n);\n    return V(e, o => r[o]);\n  });\n}\nfunction R(e) {\n  throw new v(me, `Unexpected value received: ${JSON.stringify(e)}`);\n}\nconst $ = g(\"boolean\", e => {\n    if (typeof e == \"boolean\") return e;\n    const t = String(e);\n    if (t === \"1\" || t === \"true\") return !0;\n    if (t === \"0\" || t === \"false\") return !1;\n    R(e);\n  }),\n  _ = g(\"string\", e => {\n    if (typeof e == \"string\" || typeof e == \"number\") return e.toString();\n    R(e);\n  }),\n  P = g(\"number\", e => {\n    if (typeof e == \"number\") return e;\n    if (typeof e == \"string\") {\n      const t = Number(e);\n      if (!Number.isNaN(t)) return t;\n    }\n    R(e);\n  }),\n  Ee = g(\"date\", e => e instanceof Date ? e : new Date(P()(e) * 1e3));\nfunction z(e, t) {\n  return g(t || \"searchParams\", n => {\n    typeof n != \"string\" && !(n instanceof URLSearchParams) && R(n);\n    const r = typeof n == \"string\" ? new URLSearchParams(n) : n;\n    return V(e, o => {\n      const s = r.get(o);\n      return s === null ? void 0 : s;\n    });\n  });\n}\nfunction U(e) {\n  for (const t in e) e[t] = [G(t), e[t]];\n  return e;\n}\nconst ye = e => {\n  const t = P(),\n    n = P(!0),\n    r = _(),\n    o = _(!0),\n    s = $(!0),\n    a = l(U({\n      addedToAttachmentMenu: s,\n      allowsWriteToPm: s,\n      firstName: r,\n      id: t,\n      isBot: s,\n      isPremium: s,\n      languageCode: o,\n      lastName: o,\n      photoUrl: o,\n      username: o\n    }), \"User\")(!0);\n  return z(U({\n    authDate: Ee(),\n    canSendAfter: n,\n    chat: l(U({\n      id: t,\n      type: r,\n      title: r,\n      photoUrl: o,\n      username: o\n    }), \"Chat\")(!0),\n    chatInstance: o,\n    chatType: o,\n    hash: r,\n    queryId: o,\n    receiver: a,\n    startParam: o,\n    user: a\n  }), \"initData\")(e);\n};\nfunction ve(e) {\n  return /^#[\\da-f]{6}$/i.test(e);\n}\nfunction Pe(e) {\n  return /^#[\\da-f]{3}$/i.test(e);\n}\nfunction Re(e) {\n  const t = e.replace(/\\s/g, \"\").toLowerCase();\n  if (ve(t)) return t;\n  if (Pe(t)) {\n    let r = \"#\";\n    for (let o = 0; o < 3; o += 1) r += t[1 + o].repeat(2);\n    return r;\n  }\n  const n = t.match(/^rgb\\((\\d{1,3}),(\\d{1,3}),(\\d{1,3})\\)$/) || t.match(/^rgba\\((\\d{1,3}),(\\d{1,3}),(\\d{1,3}),\\d{1,3}\\)$/);\n  if (!n) throw new Error(`Value \"${e}\" does not satisfy any of known RGB formats.`);\n  return n.slice(1).reduce((r, o) => {\n    const s = parseInt(o, 10).toString(16);\n    return r + (s.length === 1 ? \"0\" : \"\") + s;\n  }, \"#\");\n}\nconst Te = g(\"rgb\", e => Re(_()(e))),\n  Se = g(\"themeParams\", e => {\n    const t = Te(!0);\n    return Object.entries(Z(e)).reduce((n, [r, o]) => (n[we(r)] = t(o), n), {});\n  });\n// @__NO_SIDE_EFFECTS__\nfunction X(e) {\n  return JSON.stringify(Object.fromEntries(Object.entries(e).map(([t, n]) => [G(t), n])));\n}\nconst Ae = e => {\n  const t = _(),\n    n = _(!0),\n    r = $(!0);\n  return z({\n    botInline: [\"tgWebAppBotInline\", r],\n    initData: [\"tgWebAppData\", ye(!0)],\n    initDataRaw: [\"tgWebAppData\", n],\n    platform: [\"tgWebAppPlatform\", t],\n    showSettings: [\"tgWebAppShowSettings\", r],\n    startParam: [\"tgWebAppStartParam\", n],\n    themeParams: [\"tgWebAppThemeParams\", Se()],\n    version: [\"tgWebAppVersion\", t]\n  }, \"launchParams\")(e);\n};\n// @__NO_SIDE_EFFECTS__\nfunction $e(e) {\n  const {\n      initDataRaw: t,\n      startParam: n,\n      showSettings: r,\n      botInline: o\n    } = e,\n    s = new URLSearchParams();\n  return s.set(\"tgWebAppPlatform\", e.platform), s.set(\"tgWebAppThemeParams\", /* @__PURE__ */X(e.themeParams)), s.set(\"tgWebAppVersion\", e.version), t && s.set(\"tgWebAppData\", t), n && s.set(\"tgWebAppStartParam\", n), typeof r == \"boolean\" && s.set(\"tgWebAppShowSettings\", r ? \"1\" : \"0\"), typeof o == \"boolean\" && s.set(\"tgWebAppBotInline\", o ? \"1\" : \"0\"), s.toString();\n}\nconst Y = l({\n    eventType: _(),\n    eventData: e => e\n  }, \"miniAppsMessage\"),\n  Q = g(\"fn\", e => {\n    if (typeof e == \"function\") return e;\n    R(e);\n  });\nfunction Ne(e) {\n  return !!e && typeof e == \"object\" && !Array.isArray(e);\n}\nconst Ce = l({\n  TelegramWebviewProxy: l({\n    postEvent: Q()\n  })()\n});\nfunction ee(e) {\n  return Ce().isValid(e);\n}\nfunction De() {\n  try {\n    return window.self !== window.top;\n  } catch {\n    return !0;\n  }\n}\nvar Ue = Object.defineProperty,\n  je = (e, t, n) => t in e ? Ue(e, t, {\n    enumerable: !0,\n    configurable: !0,\n    writable: !0,\n    value: n\n  }) : e[t] = n,\n  te = (e, t, n) => je(e, typeof t != \"symbol\" ? t + \"\" : t, n);\nclass b extends Error {\n  constructor(t, n, r) {\n    super(typeof n == \"object\" ? n.message : n || t, {\n      cause: typeof n == \"object\" ? n.cause : r\n    }), this.type = t, Object.setPrototypeOf(this, b.prototype);\n  }\n}\nfunction x(e, t, n) {\n  return e.addEventListener(t, n), () => e.removeEventListener(t, n);\n}\nfunction L(...e) {\n  const t = e.flat(1);\n  return [t.push.bind(t), () => {\n    t.forEach(n => {\n      n();\n    });\n  }];\n}\nfunction xe(e, t) {\n  return e instanceof b && e.type === t;\n}\nfunction W(e) {\n  return t => xe(t, e);\n}\nconst ne = \"ERR_ABORTED\",\n  re = \"ERR_CANCELED\",\n  oe = \"ERR_TIMED_OUT\";\nfunction M(e) {\n  return new b(ne, {\n    cause: e\n  });\n}\nconst ot = W(oe),\n  st = W(ne),\n  at = W(re);\nfunction q(e, t) {\n  return e.reject = t.reject, e;\n}\nclass w extends Promise {\n  constructor(t, n) {\n    let r, o;\n    typeof t == \"function\" ? (r = t, o = n) : o = t;\n    let s, a;\n    super((i, c) => {\n      o || (o = {});\n      const {\n        abortSignal: u\n      } = o;\n      if (u && u.aborted) return c(M(u.reason));\n      const [f, h] = L(),\n        d = m => (...ge) => (h(), m(...ge)),\n        T = new AbortController(),\n        {\n          signal: S\n        } = T;\n      a = d(m => {\n        T.abort(m), c(m);\n      }), s = d(i), u && f(x(u, \"abort\", () => {\n        a(M(u.reason));\n      }));\n      const {\n        timeout: D\n      } = o;\n      if (D) {\n        const m = setTimeout(() => {\n          a(new b(oe, `Timeout reached: ${D}ms`));\n        }, D);\n        f(() => {\n          clearTimeout(m);\n        });\n      }\n      r && r(s, a, S);\n    }), te(this, \"reject\"), this.reject = a;\n  }\n  /**\n   * Creates a new BetterPromise instance using executor, resolving promise when a result\n   * was returned.\n   * @param fn - function returning promise result.\n   * @param options - additional options.\n   */\n  static withFn(t, n) {\n    return new w((r, o, s) => {\n      try {\n        const a = t(s);\n        return a instanceof Promise ? a.then(r, o) : r(a);\n      } catch (a) {\n        o(a);\n      }\n    }, n);\n  }\n  /**\n   * @see Promise.resolve\n   */\n  static resolve(t) {\n    return new w(n => {\n      n(t);\n    });\n  }\n  /**\n   * @see Promise.reject\n   */\n  static reject(t) {\n    return new w((n, r) => {\n      r(t);\n    });\n  }\n  /**\n   * Cancels the promise execution.\n   */\n  cancel() {\n    this.reject(new b(re));\n  }\n  /**\n   * @see Promise.catch\n   */\n  catch(t) {\n    return this.then(void 0, t);\n  }\n  /**\n   * @see Promise.finally\n   */\n  finally(t) {\n    return q(super.finally(t), this);\n  }\n  /**\n   * @see Promise.then\n   */\n  then(t, n) {\n    return q(super.then(t, n), this);\n  }\n}\nfunction F(e, t) {\n  return e.resolve = t.resolve, e;\n}\nclass A extends w {\n  constructor(t, n) {\n    let r, o;\n    typeof t == \"function\" ? (r = t, o = n) : o = t;\n    let s;\n    super((a, i, c) => {\n      s = a, r && r(a, i, c);\n    }, o), te(this, \"resolve\"), this.resolve = s;\n  }\n  /**\n   * Creates a new EnhancedPromise instance using executor, resolving promise when a result\n   * was returned.\n   * @param fn - function returning promise result.\n   * @param options - additional options.\n   */\n  static withFn(t, n) {\n    return new A((r, o, s) => w.withFn(t, {\n      abortSignal: s\n    }).then(r, o), n);\n  }\n  /**\n   * @see Promise.resolve\n   */\n  static resolve(t) {\n    return new A(n => {\n      n(t);\n    });\n  }\n  /**\n   * @see Promise.reject\n   */\n  static reject(t) {\n    return new A((n, r) => {\n      r(t);\n    });\n  }\n  /**\n   * @see Promise.catch\n   */\n  catch(t) {\n    return this.then(void 0, t);\n  }\n  /**\n   * @see Promise.finally\n   */\n  finally(t) {\n    return F(super.finally(t), this);\n  }\n  /**\n   * @see Promise.then\n   */\n  then(t, n) {\n    return F(super.then(t, n), this);\n  }\n}\nfunction it(e, t) {\n  return new w(n => {\n    setTimeout(n, e);\n  }, {\n    abortSignal: t\n  });\n}\nfunction se(e) {\n  return `tapps/${e}`;\n}\nfunction ke(e, t) {\n  sessionStorage.setItem(se(e), JSON.stringify(t));\n}\nfunction Le(e) {\n  const t = sessionStorage.getItem(se(e));\n  try {\n    return t ? JSON.parse(t) : void 0;\n  } catch {}\n}\nfunction ct(e) {\n  return e.replace(/[A-Z]/g, t => `-${t.toLowerCase()}`);\n}\nfunction ut(e) {\n  return e.replace(/[A-Z]/g, t => `_${t.toLowerCase()}`);\n}\nfunction pt(e) {\n  return e.replace(/_[a-z]/g, t => t[1].toUpperCase());\n}\n// @__NO_SIDE_EFFECTS__\nfunction We(e, t) {\n  t || (t = {});\n  const {\n    textColor: n,\n    bgColor: r,\n    shouldLog: o = !0\n  } = t;\n  function s(a, ...i) {\n    if (!o || typeof o == \"function\" && !o()) return;\n    const c = \"font-weight:bold;padding:0 5px;border-radius:5px\";\n    console[a](`%c${Intl.DateTimeFormat(\"en-GB\", {\n      hour: \"2-digit\",\n      minute: \"2-digit\",\n      second: \"2-digit\",\n      fractionalSecondDigits: 3,\n      timeZone: \"UTC\"\n    }).format(/* @__PURE__ */new Date())}%c / %c${e}`, `${c};background-color: lightblue;color:black`, \"\", `${c};${n ? `color:${n};` : \"\"}${r ? `background-color:${r}` : \"\"}`, ...i);\n  }\n  return [function (...a) {\n    s(\"log\", ...a);\n  }, function (...a) {\n    s(\"error\", ...a);\n  }];\n}\nfunction ft(e, t) {\n  document.documentElement.style.setProperty(e, t);\n}\nfunction _t(e) {\n  document.documentElement.style.removeProperty(e);\n}\nfunction Oe(e, t) {\n  t();\n}\n// @__NO_SIDE_EFFECTS__\nfunction E(e, t) {\n  t || (t = {});\n  const n = t.equals || Object.is;\n  let r = [],\n    o = e;\n  const s = u => {\n    if (!n(o, u)) {\n      const f = o;\n      o = u, Oe(c, () => {\n        [...r].forEach(([h, d]) => {\n          h(u, f), d && i(h, !0);\n        });\n      });\n    }\n  };\n  function a(u) {\n    const f = typeof u != \"object\" ? {\n      once: u\n    } : u;\n    return {\n      once: f.once || !1,\n      signal: f.signal || !1\n    };\n  }\n  const i = (u, f) => {\n      const h = a(f),\n        d = r.findIndex(([T, S]) => T === u && S.once === h.once && S.signal === h.signal);\n      d >= 0 && r.splice(d, 1);\n    },\n    c = Object.assign(function () {\n      return Ie(c), o;\n    }, {\n      destroy() {\n        r = [];\n      },\n      set: s,\n      reset() {\n        s(e);\n      },\n      sub(u, f) {\n        return r.push([u, a(f)]), () => i(u, f);\n      },\n      unsub: i,\n      unsubAll() {\n        r = r.filter(u => u[1].signal);\n      }\n    });\n  return c;\n}\nconst j = [];\nfunction Ie(e) {\n  j.length && j[j.length - 1].add(e);\n}\nconst ae = /* @__PURE__ */E(!1),\n  [O, Me] = /* @__PURE__ */We(\"Bridge\", {\n    bgColor: \"#9147ff\",\n    textColor: \"white\",\n    shouldLog: ae\n  }),\n  qe = {\n    clipboard_text_received: l({\n      req_id: _(),\n      data: e => e === null ? e : _(!0)(e)\n    }, \"clipboard_text_received\"),\n    custom_method_invoked: l({\n      req_id: _(),\n      result: e => e,\n      error: _(!0)\n    }, \"custom_method_invoked\"),\n    popup_closed: g(\"popup_closed\", e => e ? l({\n      button_id: t => t == null ? void 0 : _()(t)\n    })()(e) : {}),\n    viewport_changed: l({\n      height: P(),\n      width: e => e == null ? window.innerWidth : P()(e),\n      is_state_stable: $(),\n      is_expanded: $()\n    }, \"viewport_changed\")\n  };\nfunction Fe(e) {\n  const t = window,\n    [, n] = L(\n    // Add \"resize\" event listener to make sure, we always have fresh viewport information.\n    // The desktop version of Telegram is sometimes not sending the \"viewport_changed\"\n    // event. For example, when the Main Button is shown. That's why we should\n    // add our own listener to make sure viewport information is always fresh.\n    // Issue: https://github.com/Telegram-Mini-Apps/telegram-apps/issues/10\n    x(t, \"resize\", () => {\n      e([\"viewport_changed\", {\n        width: window.innerWidth,\n        height: window.innerHeight,\n        is_state_stable: !0,\n        is_expanded: !0\n      }]);\n    }),\n    // Add listener, which handles events sent from the Telegram web application and also events\n    // generated by the local emitEvent function.\n    x(t, \"message\", r => {\n      if (r.source !== t.parent) return;\n      let o;\n      try {\n        o = Y()(r.data);\n      } catch {\n        return;\n      }\n      const {\n          eventType: s,\n          eventData: a\n        } = o,\n        i = qe[s];\n      try {\n        const c = i ? i()(a) : a;\n        O(\"Event received:\", c ? {\n          eventType: s,\n          eventData: c\n        } : {\n          eventType: s\n        }), e([s, c]);\n      } catch (c) {\n        Me([`An error occurred processing the \"${s}\" event from the Telegram application.`, \"Please, file an issue here:\", \"https://github.com/Telegram-Mini-Apps/telegram-apps/issues/new/choose\"].join(`\n`), o, c);\n      }\n    }));\n  return n;\n}\nconst N = /* @__PURE__ */E(),\n  C = /* @__PURE__ */E();\nfunction ie() {\n  return C() || C.set(Fe(N.set)), N;\n}\nconst y = /* @__PURE__ */E({});\nfunction ce(e) {\n  let t = y()[e];\n  return t || (t = /* @__PURE__ */E(void 0, {\n    equals() {\n      return !1;\n    }\n  }), ie().sub(n => {\n    n && n[0] === e && t.set(n[1]);\n  }), y.set({\n    ...y(),\n    [e]: t\n  })), t;\n}\nfunction Je(e, t, n) {\n  return ce(e).sub(t, n);\n}\nconst Be = \"ERR_METHOD_UNSUPPORTED\",\n  He = \"ERR_RETRIEVE_LP_FAILED\",\n  Ge = \"ERR_METHOD_PARAMETER_UNSUPPORTED\",\n  Ke = \"ERR_UNKNOWN_ENV\",\n  Ve = \"ERR_INVOKE_CUSTOM_METHOD_RESPONSE\",\n  ue = /* @__PURE__ */E(\"https://web.telegram.org\");\nfunction pe(e, t) {\n  O(\"Posting event:\", t ? {\n    eventType: e,\n    eventData: t\n  } : {\n    eventType: e\n  });\n  const n = window;\n  if (ee(n)) {\n    n.TelegramWebviewProxy.postEvent(e, JSON.stringify(t));\n    return;\n  }\n  const r = JSON.stringify({\n    eventType: e,\n    eventData: t\n  });\n  if (De()) return n.parent.postMessage(r, ue());\n  const {\n    external: o\n  } = n;\n  if (l({\n    notify: Q()\n  })().isValid(o)) {\n    o.notify(r);\n    return;\n  }\n  throw new b(Ke);\n}\nfunction fe(e, t, n) {\n  n || (n = {});\n  const {\n      capture: r\n    } = n,\n    [o, s] = L();\n  return new w(a => {\n    (Array.isArray(t) ? t : [t]).forEach(i => {\n      o(Je(i, c => {\n        (!r || (Array.isArray(t) ? r({\n          event: i,\n          payload: c\n        }) : r(c))) && a(c);\n      }));\n    }), (n.postEvent || pe)(e, n.params);\n  }, n).finally(s);\n}\nfunction I(e) {\n  return Ae()(e);\n}\nfunction _e(e) {\n  return I(e.replace(/^[^?#]*[?#]/, \"\").replace(/[?#]/g, \"&\"));\n}\nfunction Ze() {\n  return _e(window.location.href);\n}\nfunction ze() {\n  const e = performance.getEntriesByType(\"navigation\")[0];\n  if (!e) throw new Error(\"Unable to get first navigation entry.\");\n  return _e(e.name);\n}\nconst Xe = \"launchParams\";\nfunction Ye() {\n  return I(Le(Xe) || \"\");\n}\nfunction le(e) {\n  ke(\"launchParams\", /* @__PURE__ */$e(e));\n}\nfunction be(e) {\n  return e instanceof Error ? e.message + (e.cause ? `\n  ${be(e.cause)}` : \"\") : JSON.stringify(e);\n}\nfunction Qe() {\n  const e = [];\n  for (const t of [\n  // Try to retrieve launch parameters from the current location. This method can return\n  // nothing in case, location was changed, and then the page was reloaded.\n  Ze,\n  // Then, try using the lower level API - window.performance.\n  ze,\n  // Finally, try to extract launch parameters from the session storage.\n  Ye]) try {\n    const n = t();\n    return le(n), n;\n  } catch (n) {\n    e.push(n);\n  }\n  throw new b(He, [\"Unable to retrieve launch parameters from any known source. Perhaps, you have opened your app outside Telegram?\", \"ðŸ“– Refer to docs for more information:\", \"https://docs.telegram-mini-apps.com/packages/telegram-apps-sdk/environment\", \"Collected errors:\", ...e.map(t => `â€” ${be(t)}`)].join(`\n`));\n}\nfunction lt(e) {\n  if (e === \"simple\") try {\n    return Qe(), !0;\n  } catch {\n    return !1;\n  }\n  return w.withFn(async () => {\n    if (ee(window)) return !0;\n    try {\n      return await fe(\"web_app_request_theme\", \"theme_changed\", {\n        timeout: 100\n      }), !0;\n    } catch {\n      return !1;\n    }\n  }, e);\n}\nfunction k(e, t) {\n  window.dispatchEvent(new MessageEvent(\"message\", {\n    data: JSON.stringify({\n      eventType: e,\n      eventData: t\n    }),\n    // We specify window.parent to imitate the case, the parent iframe sent us this event.\n    source: window.parent\n  }));\n}\nfunction et(e, t) {\n  if (typeof t == \"string\") try {\n    const {\n      eventType: n\n    } = Y()(t);\n    n === \"web_app_request_theme\" && k(\"theme_changed\", {\n      theme_params: JSON.parse(/* @__PURE__ */X(e))\n    }), n === \"web_app_request_viewport\" && k(\"viewport_changed\", {\n      width: window.innerWidth,\n      height: window.innerHeight,\n      is_state_stable: !0,\n      is_expanded: !0\n    });\n  } catch {}\n}\nfunction bt(e) {\n  var r;\n  const t = typeof e == \"string\" ? I(e) : e;\n  le(t);\n  const n = (r = window.TelegramWebviewProxy) == null ? void 0 : r.postEvent;\n  window.TelegramWebviewProxy = {\n    postEvent(o, s) {\n      et(t.themeParams, JSON.stringify({\n        eventType: o,\n        eventData: s\n      })), n == null || n(o, s);\n    }\n  }, O(\"Environment was mocked by the mockTelegramEnv function\");\n}\nfunction gt() {\n  [[\"TelegramGameProxy_receiveEvent\"],\n  // Windows Phone.\n  [\"TelegramGameProxy\", \"receiveEvent\"],\n  // Desktop.\n  [\"Telegram\", \"WebView\", \"receiveEvent\"]\n  // Android and iOS.\n  ].forEach(e => {\n    let t = window;\n    e.forEach((n, r, o) => {\n      if (r === o.length - 1) {\n        t[n] = k;\n        return;\n      }\n      n in t || (t[n] = {}), t = t[n];\n    });\n  });\n}\nfunction wt() {\n  [\"TelegramGameProxy_receiveEvent\", \"TelegramGameProxy\", \"Telegram\"].forEach(e => {\n    delete window[e];\n  });\n}\nfunction ht(e, t, n) {\n  ce(e).unsub(t, n);\n}\nfunction dt(e, t) {\n  return ie().sub(e, t);\n}\nfunction mt(e, t) {\n  N.unsub(e, t);\n}\nfunction tt(e) {\n  return ({\n    req_id: t\n  }) => t === e;\n}\nfunction J(e) {\n  return e.split(\".\").map(Number);\n}\nfunction nt(e, t) {\n  const n = J(e),\n    r = J(t),\n    o = Math.max(n.length, r.length);\n  for (let s = 0; s < o; s += 1) {\n    const a = n[s] || 0,\n      i = r[s] || 0;\n    if (a !== i) return a > i ? 1 : -1;\n  }\n  return 0;\n}\nfunction p(e, t) {\n  return nt(e, t) <= 0;\n}\nfunction B(e, t, n) {\n  if (typeof n == \"string\") {\n    if (e === \"web_app_open_link\") {\n      if (t === \"try_instant_view\") return p(\"6.4\", n);\n      if (t === \"try_browser\") return p(\"7.6\", n);\n    }\n    if (e === \"web_app_set_header_color\" && t === \"color\") return p(\"6.9\", n);\n    if (e === \"web_app_close\" && t === \"return_back\") return p(\"7.6\", n);\n    if (e === \"web_app_setup_main_button\" && t === \"has_shine_effect\") return p(\"7.10\", n);\n  }\n  switch (e) {\n    case \"web_app_open_tg_link\":\n    case \"web_app_open_invoice\":\n    case \"web_app_setup_back_button\":\n    case \"web_app_set_background_color\":\n    case \"web_app_set_header_color\":\n    case \"web_app_trigger_haptic_feedback\":\n      return p(\"6.1\", t);\n    case \"web_app_open_popup\":\n      return p(\"6.2\", t);\n    case \"web_app_close_scan_qr_popup\":\n    case \"web_app_open_scan_qr_popup\":\n    case \"web_app_read_text_from_clipboard\":\n      return p(\"6.4\", t);\n    case \"web_app_switch_inline_query\":\n      return p(\"6.7\", t);\n    case \"web_app_invoke_custom_method\":\n    case \"web_app_request_write_access\":\n    case \"web_app_request_phone\":\n      return p(\"6.9\", t);\n    case \"web_app_setup_settings_button\":\n      return p(\"6.10\", t);\n    case \"web_app_biometry_get_info\":\n    case \"web_app_biometry_open_settings\":\n    case \"web_app_biometry_request_access\":\n    case \"web_app_biometry_request_auth\":\n    case \"web_app_biometry_update_token\":\n      return p(\"7.2\", t);\n    case \"web_app_setup_swipe_behavior\":\n      return p(\"7.7\", t);\n    case \"web_app_share_to_story\":\n      return p(\"7.8\", t);\n    case \"web_app_setup_secondary_button\":\n    case \"web_app_set_bottom_bar_color\":\n      return p(\"7.10\", t);\n    default:\n      return [\"iframe_ready\", \"iframe_will_reload\", \"web_app_close\", \"web_app_data_send\", \"web_app_expand\", \"web_app_open_link\", \"web_app_ready\", \"web_app_request_theme\", \"web_app_request_viewport\", \"web_app_setup_main_button\", \"web_app_setup_closing_behavior\"].includes(e);\n  }\n}\nfunction Et(e, t) {\n  t || (t = \"strict\");\n  const n = typeof t == \"function\" ? t : r => {\n    const {\n      method: o,\n      version: s\n    } = r;\n    let a, i;\n    if (\"param\" in r ? (a = `Parameter \"${r.param}\" of \"${o}\" method is unsupported in Mini Apps version ${s}`, i = Ge) : (a = `Method \"${o}\" is unsupported in Mini Apps version ${s}`, i = Be), t === \"strict\") throw new b(i, a);\n    return console.warn(a);\n  };\n  return (r, o) => B(r, e) ? Ne(o) && r === \"web_app_set_header_color\" && \"color\" in o && !B(r, \"color\", e) ? n({\n    version: e,\n    method: r,\n    param: \"color\"\n  }) : pe(r, o) : n({\n    version: e,\n    method: r\n  });\n}\nfunction yt(e, t, n, r) {\n  return fe(\"web_app_invoke_custom_method\", \"custom_method_invoked\", {\n    ...(r || {}),\n    params: {\n      method: e,\n      params: t,\n      req_id: n\n    },\n    capture: tt(n)\n  }).then(({\n    result: o,\n    error: s\n  }) => {\n    if (s) throw new b(Ve, s);\n    return o;\n  });\n}\nfunction rt(e) {\n  e.unsubAll(), e.reset();\n}\nfunction vt() {\n  var e;\n  (e = C()) == null || e(), [...Object.values(y()), y, N, C, ue, ae].forEach(rt);\n}\nexport { ae as $debug, ue as $targetOrigin, w as CancelablePromise, ne as ERR_ABORTED, re as ERR_CANCELED, Ve as ERR_CUSTOM_METHOD_ERR_RESPONSE, Ge as ERR_METHOD_PARAMETER_UNSUPPORTED, Be as ERR_METHOD_UNSUPPORTED, He as ERR_RETRIEVE_LP_FAILED, oe as ERR_TIMED_OUT, Ke as ERR_UNKNOWN_ENV, A as EnhancedPromise, b as TypedError, x as addEventListener, ct as camelToKebab, ut as camelToSnake, tt as captureSameReq, nt as compareVersions, M as createAbortError, L as createCbCollector, We as createLogger, Et as createPostEvent, W as createTypedErrorPredicate, gt as defineEventHandlers, _t as deleteCssVar, k as emitMiniAppsEvent, Le as getStorageValue, ee as hasWebviewProxy, yt as invokeCustomMethod, st as isAbortError, at as isCanceledError, De as isIframe, lt as isTMA, ot as isTimeoutError, bt as mockTelegramEnv, ht as off, Je as on, pe as postEvent, wt as removeEventHandlers, fe as request, vt as resetPackageState, Qe as retrieveLaunchParams, ft as setCssVar, ke as setStorageValue, it as sleep, pt as snakeToCamel, dt as subscribe, B as supports, mt as unsubscribe };\n//# sourceMappingURL=index.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}