{"ast":null,"code":"// src/ACDappClient.ts\nimport { chainIdToNetwork, ConnectRequest, ConnectResponse, DisconnectRequest, GetConnectedAccountsRequest, GetConnectedAccountsResponse, makeUserApproval, SignAndSubmitTransactionRequest, SignAndSubmitTransactionResponse, SignMessageRequest, SignMessageResponse, SignTransactionRequest, SignTransactionResponse } from \"@aptos-connect/wallet-api\";\nimport { WebWalletTransport } from \"@aptos-connect/web-transport\";\nimport { AccountAddress as AccountAddress3, AnySignature, AptosConfig as AptosConfig2, Deserializer, Ed25519Signature, FeePayerRawTransaction, generateRawTransaction, Hex } from \"@aptos-labs/ts-sdk\";\nimport { NetworkName as NetworkName2 } from \"@identity-connect/api\";\nimport { createEd25519KeyPair, encodeBase64 as encodeBase642 } from \"@identity-connect/crypto\";\n\n// src/constants.ts\nvar DEFAULT_FRONTEND_URL = \"https://aptosconnect.app\";\n\n// src/conversion.ts\nimport { AccountAddress, generateTransactionPayload, generateTransactionPayloadWithABI } from \"@aptos-labs/ts-sdk\";\nfunction convertToSerializableArgument(argument) {\n  if (argument === void 0 || argument === null) {\n    return argument;\n  }\n  if (Array.isArray(argument)) {\n    return argument.map(subArgument => convertToSerializableArgument(subArgument));\n  }\n  if (typeof argument === \"string\" || typeof argument === \"number\" || typeof argument === \"boolean\" || argument instanceof Uint8Array) {\n    return argument;\n  }\n  if (typeof argument === \"bigint\") {\n    return argument.toString();\n  }\n  if (argument instanceof ArrayBuffer) {\n    return new Uint8Array(argument);\n  }\n  if (\"values\" in argument) {\n    return argument.values.map(subArgument => convertToSerializableArgument(subArgument));\n  }\n  if (\"data\" in argument) {\n    return AccountAddress.from(argument.data).toString();\n  }\n  if (argument.value === void 0) {\n    return void 0;\n  }\n  if (typeof argument.value === \"string\" || typeof argument.value === \"number\" || typeof argument.value === \"boolean\" || argument.value instanceof Uint8Array) {\n    return argument.value;\n  }\n  if (typeof argument.value === \"bigint\") {\n    return argument.value.toString();\n  }\n  throw new Error(\"Unexpected argument\");\n}\nfunction normalizePayloadForIC(payload, aptosConfig) {\n  if (\"bcsToBytes\" in payload) {\n    return payload;\n  }\n  if (\"bytecode\" in payload) {\n    return generateTransactionPayload(payload);\n  }\n  if (aptosConfig) {\n    return payload.abi !== void 0 ? generateTransactionPayloadWithABI({\n      ...payload,\n      abi: payload.abi\n    }) : generateTransactionPayload({\n      aptosConfig,\n      ...payload\n    });\n  }\n  const entryFunctionPayload = {\n    arguments: payload.functionArguments.map(convertToSerializableArgument),\n    function: payload.function,\n    type: \"entry_function_payload\",\n    type_arguments: (payload.typeArguments ?? []).map(ta => ta.toString())\n  };\n  return \"multisigAddress\" in payload ? {\n    multisig_address: AccountAddress.from(payload.multisigAddress).toString(),\n    transaction_payload: entryFunctionPayload,\n    type: \"multisig_payload\"\n  } : entryFunctionPayload;\n}\n\n// src/PairingClient.ts\nimport { AccountAddress as AccountAddress2 } from \"@aptos-labs/ts-sdk\";\nimport { NetworkName, SigningRequestStatus, SigningRequestTypes } from \"@identity-connect/api\";\nimport { decodeBase64, decryptEnvelope, deserializeEd25519PublicKeyB64, deserializePublicKeyB64, encodeBase64, encryptAndSignEnvelope, KeyTypes, toKey } from \"@identity-connect/crypto\";\nimport { deserializeSignTransactionResponseArgs, serializeSignAndSubmitTransactionRequestArgs, serializeSignTransactionRequestArgs } from \"@identity-connect/wallet-api\";\nimport axios, { AxiosError, isAxiosError } from \"axios\";\n\n// src/errors.ts\nvar SignatureRequestError = class _SignatureRequestError extends Error {\n  constructor(status) {\n    super(status);\n    this.name = \"SignatureRequestError\";\n    Object.setPrototypeOf(this, _SignatureRequestError.prototype);\n  }\n};\nvar UnexpectedSignatureResponseError = class _UnexpectedSignatureResponseError extends Error {\n  constructor(missingFields) {\n    const message = `Missing the following fields: ${missingFields.join(\", \")}`;\n    super(message);\n    this.name = \"UnexpectedSignatureResponseError\";\n    Object.setPrototypeOf(this, _UnexpectedSignatureResponseError.prototype);\n  }\n};\nvar PairingExpiredError = class _PairingExpiredError extends Error {\n  constructor() {\n    super();\n    this.name = \"PairingExpiredError\";\n    Object.setPrototypeOf(this, _PairingExpiredError.prototype);\n  }\n};\nvar UnregisteredDappError = class _UnregisteredDappError extends Error {\n  constructor() {\n    super(\"Dapp ID is invalid or not associated with a registered Dapp.\");\n    this.name = \"UnregisteredDappError\";\n    Object.setPrototypeOf(this, _UnregisteredDappError.prototype);\n  }\n};\n\n// src/state.ts\nvar DAPP_PAIRINGS_WINDOW_STORAGE_KEY = \"icDappPairings\";\nvar windowStateAccessors = {\n  async get(address) {\n    const pairings = await this.getAll();\n    return pairings[address];\n  },\n  async getAll() {\n    const serialized = window.localStorage.getItem(DAPP_PAIRINGS_WINDOW_STORAGE_KEY);\n    return serialized ? JSON.parse(serialized) : {};\n  },\n  async update(address, pairing) {\n    const pairings = await this.getAll();\n    if (pairing === void 0) {\n      delete pairings[address];\n    } else {\n      pairings[address] = pairing;\n    }\n    const newSerialized = JSON.stringify(pairings);\n    window.localStorage.setItem(DAPP_PAIRINGS_WINDOW_STORAGE_KEY, newSerialized);\n  }\n};\n\n// src/utils.ts\nvar SIGN_MESSAGE_RESPONSE_REQUIRED_FIELDS = [\"address\", \"application\", \"chainId\", \"fullMessage\", \"message\", \"nonce\", \"prefix\", \"signature\"];\nfunction validateSignMessageResponse(response) {\n  const providedFields = new Set(Object.keys(response));\n  const missingFields = SIGN_MESSAGE_RESPONSE_REQUIRED_FIELDS.filter(field => !providedFields.has(field));\n  if (missingFields.length > 0) {\n    throw new UnexpectedSignatureResponseError(missingFields);\n  }\n}\nvar SIGN_AND_SUBMIT_TRANSACTION_RESPONSE_REQUIRED_FIELDS = [\"hash\"];\nfunction validateSignAndSubmitTransactionResponse(response) {\n  const providedFields = new Set(Object.keys(response));\n  const missingFields = SIGN_AND_SUBMIT_TRANSACTION_RESPONSE_REQUIRED_FIELDS.filter(field => !providedFields.has(field));\n  if (missingFields.length > 0) {\n    throw new UnexpectedSignatureResponseError(missingFields);\n  }\n}\n\n// src/PairingClient.ts\nvar API_VERSION = \"0.2.0\";\nvar SIGNING_REQUEST_POLLING_INTERVAL = 2500;\nvar SEQUENCE_NUMBER_MISMATCH_PATTERN = /^Sequence number mismatch, expected (?:\\S+ to be )?(\\d+)/;\nasync function waitFor(milliseconds) {\n  return new Promise(resolve => {\n    setTimeout(resolve, milliseconds);\n  });\n}\nasync function withRetries(requestFn, onError, retries = 1) {\n  for (let i = 0; i < retries; i += 1) {\n    try {\n      return await requestFn();\n    } catch (err) {\n      onError(err);\n    }\n  }\n  return requestFn();\n}\nvar ACPairingClient = class {\n  constructor({\n    accessors = windowStateAccessors,\n    axiosConfig,\n    defaultNetworkName = NetworkName.MAINNET\n  } = {}) {\n    // endregion\n    this.onDisconnectListeners = /* @__PURE__ */new Set();\n    this.accessors = accessors;\n    this.defaultNetworkName = defaultNetworkName;\n    this.axiosInstance = axios.create({\n      baseURL: DEFAULT_FRONTEND_URL,\n      ...axiosConfig\n    });\n    const isClientSideRendering = typeof window !== \"undefined\";\n    this.initPromise = isClientSideRendering ? this.syncFirstPairing() : void 0;\n  }\n  async getPairing(id) {\n    const response = await this.axiosInstance.get(`v1/pairing/${id}/`);\n    return response.data.data.pairing;\n  }\n  async syncFirstPairing() {\n    const pairings = await this.accessors.getAll();\n    const firstPairing = Object.values(pairings)[0];\n    if (firstPairing === void 0) {\n      return;\n    }\n    try {\n      const {\n        dappSpecificWallet,\n        maxDappSequenceNumber\n      } = await this.getPairing(firstPairing.pairingId);\n      await this.accessors.update(firstPairing.accountAddress, {\n        ...firstPairing,\n        currSequenceNumber: maxDappSequenceNumber,\n        dappWalletId: dappSpecificWallet?.id\n      });\n    } catch (err) {\n      await this.accessors.update(firstPairing.accountAddress, void 0);\n    }\n  }\n  async createSigningRequest(pairing, type, networkName, requestBody) {\n    const dappEd25519SecretKey = decodeBase64(pairing.dappEd25519SecretKeyB64);\n    const dappEd25519PublicKey = decodeBase64(pairing.dappEd25519PublicKeyB64);\n    const accountTransportEd25519PublicKey = decodeBase64(pairing.accountTransportEd25519PublicKeyB64);\n    let sequenceNumber = pairing.currSequenceNumber + 1;\n    return withRetries(async () => {\n      const requestEnvelope = await encryptAndSignEnvelope(toKey(dappEd25519SecretKey, KeyTypes.Ed25519SecretKey), toKey(dappEd25519PublicKey, KeyTypes.Ed25519PublicKey), toKey(accountTransportEd25519PublicKey, KeyTypes.Ed25519PublicKey), sequenceNumber, {\n        apiVersion: API_VERSION,\n        networkName,\n        requestType: type\n      }, requestBody);\n      const response = await this.axiosInstance.post(`v1/pairing/${pairing.pairingId}/signing-request/`, requestEnvelope);\n      await this.accessors.update(pairing.accountAddress, {\n        ...pairing,\n        currSequenceNumber: sequenceNumber\n      });\n      return response.data.data.signingRequest;\n    }, err => {\n      if (isAxiosError(err)) {\n        const errorMessage = err.response?.data?.message;\n        const expectedSequenceNumber = errorMessage?.match(SEQUENCE_NUMBER_MISMATCH_PATTERN)?.[1];\n        if (expectedSequenceNumber !== void 0) {\n          sequenceNumber = Number(expectedSequenceNumber);\n          return;\n        }\n      }\n      throw err;\n    });\n  }\n  async getSigningRequest(id) {\n    const response = await this.axiosInstance.get(`v1/signing-request/${id}/`, {\n      validateStatus: status => status === 200 || status === 404\n    });\n    return response.data?.data?.signingRequest;\n  }\n  async deletePairing(pairingId, secretKey, publicKey) {\n    const requestEnvelope = await encryptAndSignEnvelope(secretKey, publicKey, publicKey, 0,\n    // ignored\n    {}, {});\n    await this.axiosInstance.post(`v1/pairing/${pairingId}/delete/`, requestEnvelope, {\n      validateStatus: status => status === 204 || status === 404\n    });\n  }\n  async cancelSigningRequest(pairing, id) {\n    const sequenceNumber = pairing.currSequenceNumber;\n    const dappEd25519SecretKey = decodeBase64(pairing.dappEd25519SecretKeyB64);\n    const dappEd25519PublicKey = decodeBase64(pairing.dappEd25519PublicKeyB64);\n    const accountTransportEd25519PublicKey = decodeBase64(pairing.accountTransportEd25519PublicKeyB64);\n    const requestEnvelope = await encryptAndSignEnvelope(toKey(dappEd25519SecretKey, KeyTypes.Ed25519SecretKey), toKey(dappEd25519PublicKey, KeyTypes.Ed25519PublicKey), toKey(accountTransportEd25519PublicKey, KeyTypes.Ed25519PublicKey), sequenceNumber + 1, {}, {});\n    const response = await this.axiosInstance.patch(`v1/signing-request/${id}/cancel/`, requestEnvelope);\n    await this.accessors.update(pairing.accountAddress, {\n      ...pairing,\n      currSequenceNumber: sequenceNumber + 1\n    });\n    return response.data.data.signingRequest;\n  }\n  async signRequest(address, type, requestBody, {\n    cancelToken,\n    networkName\n  } = {}) {\n    await this.initPromise;\n    const pairing = await this.accessors.get(address);\n    if (pairing === void 0) {\n      throw new Error(\"The requested account is not paired\");\n    }\n    let signingRequest;\n    try {\n      signingRequest = await this.createSigningRequest(pairing, type, networkName || this.defaultNetworkName, requestBody);\n      while (signingRequest.status === \"PENDING\") {\n        await waitFor(SIGNING_REQUEST_POLLING_INTERVAL);\n        if (cancelToken?.cancelled) {\n          signingRequest.status = SigningRequestStatus.CANCELLED;\n          break;\n        }\n        signingRequest = (await this.getSigningRequest(signingRequest.id)) ?? signingRequest;\n      }\n    } catch (err) {\n      if (isAxiosError(err) && err.code === \"404\") {\n        await this.accessors.update(address, void 0);\n        for (const listener of this.onDisconnectListeners) {\n          listener(address);\n        }\n        throw new PairingExpiredError();\n      }\n      throw err;\n    }\n    if (signingRequest.status !== \"APPROVED\") {\n      throw new SignatureRequestError(signingRequest.status);\n    }\n    const decrypted = decryptEnvelope(toKey(decodeBase64(pairing.accountTransportEd25519PublicKeyB64), KeyTypes.Ed25519PublicKey), toKey(decodeBase64(pairing.dappEd25519SecretKeyB64), KeyTypes.Ed25519SecretKey), signingRequest.responseEnvelope);\n    return decrypted.privateMessage;\n  }\n  // region Public API\n  /**\n   * Requests a connection to an account (internally known as pairing).\n   * @returns either the address of the connected account, or undefined if the\n   * connection was cancelled.\n   */\n  async addPairing({\n    publicKey,\n    secretKey\n  }, finalizedPairing) {\n    await this.accessors.update(finalizedPairing.account.accountAddress, {\n      accountAddress: finalizedPairing.account.accountAddress,\n      accountAlias: finalizedPairing.account.userSubmittedAlias ?? void 0,\n      accountPublicKeyB64: finalizedPairing.account.publicKeyB64,\n      accountTransportEd25519PublicKeyB64: finalizedPairing.account.transportEd25519PublicKeyB64,\n      currSequenceNumber: finalizedPairing.maxDappSequenceNumber,\n      dappEd25519PublicKeyB64: encodeBase64(publicKey.key),\n      dappEd25519SecretKeyB64: encodeBase64(secretKey.key),\n      dappWalletId: finalizedPairing.dappSpecificWalletId,\n      pairingId: finalizedPairing.id\n    });\n  }\n  async disconnect(address) {\n    const pairing = await this.accessors.get(address);\n    if (pairing === void 0) {\n      throw new Error(\"The specified account is not paired\");\n    }\n    const dappEd25519SecretKey = decodeBase64(pairing.dappEd25519SecretKeyB64);\n    const dappEd25519PublicKey = decodeBase64(pairing.dappEd25519PublicKeyB64);\n    await this.deletePairing(pairing.pairingId, toKey(dappEd25519SecretKey, KeyTypes.Ed25519SecretKey), toKey(dappEd25519PublicKey, KeyTypes.Ed25519PublicKey));\n    await this.accessors.update(address, void 0);\n    for (const listener of this.onDisconnectListeners) {\n      listener(address);\n    }\n  }\n  async signMessage(address, args, options) {\n    const response = await this.signRequest(address, SigningRequestTypes.SIGN_MESSAGE, args, options);\n    validateSignMessageResponse(response);\n    return response;\n  }\n  async signTransaction(address, args, options) {\n    const serializedRequestArgs = serializeSignTransactionRequestArgs(args);\n    const serializedResponseArgs = await this.signRequest(address, SigningRequestTypes.SIGN_TRANSACTION, serializedRequestArgs, options);\n    return deserializeSignTransactionResponseArgs(serializedResponseArgs);\n  }\n  // endregion\n  async signAndSubmitTransaction(address, args, options) {\n    const serializedRequestArgs = serializeSignAndSubmitTransactionRequestArgs(args);\n    try {\n      const responseArgs = await this.signRequest(address, SigningRequestTypes.SIGN_AND_SUBMIT_TRANSACTION, serializedRequestArgs, options);\n      validateSignAndSubmitTransactionResponse(responseArgs);\n      return responseArgs;\n    } catch (e) {\n      if (e instanceof AxiosError && e.response?.data?.message) {\n        throw new Error(e.response?.data?.message);\n      }\n      throw e;\n    }\n  }\n  async getConnectedAccounts() {\n    await this.initPromise;\n    const pairings = await this.accessors.getAll();\n    return Object.values(pairings).map(({\n      accountAddress,\n      accountEd25519PublicKeyB64,\n      accountPublicKeyB64\n    }) => ({\n      address: AccountAddress2.from(accountAddress),\n      publicKey: accountPublicKeyB64 !== void 0 ? deserializePublicKeyB64(accountPublicKeyB64) : deserializeEd25519PublicKeyB64(accountEd25519PublicKeyB64)\n    }));\n  }\n  onDisconnect(listener) {\n    this.onDisconnectListeners.add(listener);\n    return () => this.onDisconnectListeners.delete(listener);\n  }\n};\n\n// src/ACDappClient.ts\nvar ACDappClient = class {\n  constructor({\n    backendBaseURL,\n    dappId,\n    dappImageURI,\n    dappName,\n    defaultNetworkName = NetworkName2.MAINNET,\n    frontendBaseURL = DEFAULT_FRONTEND_URL,\n    provider = \"google\"\n  } = {}) {\n    this.defaultNetworkName = defaultNetworkName;\n    this.dappInfo = {\n      domain: window.location.origin,\n      imageURI: dappImageURI,\n      name: dappName ?? document.title\n    };\n    this.transport = new WebWalletTransport(frontendBaseURL, provider);\n    this.dappId = dappId;\n    this.pairingClient = new ACPairingClient({\n      axiosConfig: {\n        baseURL: backendBaseURL ?? frontendBaseURL\n      },\n      defaultNetworkName\n    });\n  }\n  // region Public API\n  async getKeylessAccounts() {\n    const serializedRequest = GetConnectedAccountsRequest.serialize(this.dappInfo);\n    const serializedResponse = await this.transport.sendRequest(serializedRequest);\n    const response = GetConnectedAccountsResponse.deserialize(serializedResponse);\n    return response.args;\n  }\n  async getIcAccounts() {\n    return this.pairingClient.getConnectedAccounts() ?? [];\n  }\n  async isIcAccount(address) {\n    const icAccounts = await this.getIcAccounts();\n    return icAccounts.find(account => account.address.equals(AccountAddress3.from(address))) !== void 0;\n  }\n  async getConnectedAccounts() {\n    const keylessAccounts = await this.getKeylessAccounts();\n    const icAccounts = await this.getIcAccounts();\n    return [...keylessAccounts, ...icAccounts];\n  }\n  async disconnect(address) {\n    if (await this.isIcAccount(address)) {\n      const stringAddress = AccountAddress3.from(address).toString();\n      await this.pairingClient.disconnect(stringAddress);\n    } else {\n      const serializedRequest = DisconnectRequest.serialize(this.dappInfo);\n      await this.transport.sendRequest(serializedRequest);\n    }\n  }\n  async connect({\n    claimOptions,\n    preferredWalletName\n  } = {}) {\n    const dappKeypair = createEd25519KeyPair();\n    const injectedPreferredWalletName = typeof window !== \"undefined\" ? window.AC_PREFERRED_WALLET_NAME : void 0;\n    const requestArgs = {\n      claimOptions,\n      dappEd25519PublicKeyB64: encodeBase642(dappKeypair.publicKey.key),\n      dappId: this.dappId,\n      preferredWalletName: preferredWalletName ?? injectedPreferredWalletName\n    };\n    const serializedRequest = ConnectRequest.serialize(this.dappInfo, requestArgs);\n    const serializedResponse = await this.transport.sendRequest(serializedRequest);\n    const response = ConnectResponse.deserialize(serializedResponse);\n    if (response.args.status === \"approved\") {\n      const {\n        account,\n        pairing\n      } = response.args.args;\n      if (pairing) {\n        await this.pairingClient.addPairing(dappKeypair, pairing);\n      }\n      return makeUserApproval({\n        account\n      });\n    }\n    return response.args;\n  }\n  async signMessage(args) {\n    const {\n      signerAddress\n    } = args;\n    if (await this.isIcAccount(signerAddress)) {\n      const {\n        chainId\n      } = args;\n      const network = chainIdToNetwork(chainId);\n      let message;\n      let nonce;\n      try {\n        message = new TextDecoder().decode(args.message);\n        nonce = new TextDecoder().decode(args.nonce);\n      } catch (err) {\n        throw new Error(\"Only UTF-8 encoded text is supported when using IC\");\n      }\n      const {\n        fullMessage,\n        signature: hexSignature\n      } = await this.pairingClient.signMessage(signerAddress.toString(), {\n        address: true,\n        application: true,\n        chainId: true,\n        message,\n        nonce\n      }, {\n        networkName: network\n      });\n      const signatureBytes = Hex.fromHexInput(hexSignature).toUint8Array();\n      const signature = signatureBytes.length === Ed25519Signature.LENGTH ? new Ed25519Signature(signatureBytes) : AnySignature.deserialize(new Deserializer(signatureBytes));\n      return makeUserApproval({\n        fullMessage,\n        signature\n      });\n    }\n    const serializedRequest = SignMessageRequest.serialize(this.dappInfo, args);\n    const serializedResponse = await this.transport.sendRequest(serializedRequest);\n    const response = SignMessageResponse.deserialize(serializedResponse);\n    return response.args;\n  }\n  async signTransaction(args) {\n    const normalizedArgs = \"transaction\" in args ? SignTransactionRequest.normalizeArgs(args) : args;\n    const {\n      signerAddress\n    } = args;\n    if (await this.isIcAccount(signerAddress)) {\n      const {\n        expirationSecondsFromNow,\n        expirationTimestamp,\n        feePayer,\n        gasUnitPrice,\n        maxGasAmount,\n        network,\n        payload,\n        secondarySigners,\n        sender,\n        sequenceNumber\n      } = normalizedArgs;\n      if (feePayer !== void 0) {\n        throw new Error(\"Sponsored transaction not currently supported\");\n      }\n      if (secondarySigners && secondarySigners.length > 0) {\n        throw new Error(\"Multi-agent transactions not currently supported\");\n      }\n      if (!(\"bcsToBytes\" in payload)) {\n        throw new Error(\"Payload input format is only supported with Keyless accounts.\");\n      }\n      const responseArgs = await this.pairingClient.signTransaction(signerAddress.toString(), {\n        options: {\n          expirationSecondsFromNow,\n          expirationTimestamp,\n          gasUnitPrice,\n          maxGasAmount,\n          sender: sender?.address.toString(),\n          sequenceNumber: sequenceNumber !== void 0 ? Number(sequenceNumber) : void 0\n        },\n        payload\n      }, {\n        networkName: network\n      });\n      return makeUserApproval({\n        authenticator: responseArgs.accountAuthenticator,\n        rawTransaction: responseArgs.rawTxn\n      });\n    }\n    const serializedRequest = SignTransactionRequest.serialize(this.dappInfo, normalizedArgs);\n    const serializedResponse = await this.transport.sendRequest(serializedRequest);\n    const response = SignTransactionResponse.deserialize(serializedResponse);\n    return response.args;\n  }\n  async signAndSubmitTransaction(args) {\n    const {\n      signerAddress\n    } = args;\n    if (await this.isIcAccount(signerAddress)) {\n      const {\n        expirationTimestamp,\n        feePayer,\n        gasUnitPrice,\n        maxGasAmount,\n        network\n      } = args;\n      const aptosConfig = new AptosConfig2({\n        network\n      });\n      let convertedArgs;\n      if (feePayer !== void 0) {\n        const payload = await normalizePayloadForIC(args.payload, aptosConfig);\n        const rawTxn = await generateRawTransaction({\n          aptosConfig,\n          feePayerAddress: feePayer.address,\n          options: {\n            gasUnitPrice,\n            maxGasAmount\n          },\n          payload,\n          sender: signerAddress\n        });\n        convertedArgs = {\n          feePayerAuthenticator: feePayer.authenticator,\n          rawTxn: new FeePayerRawTransaction(rawTxn, [], feePayer.address)\n        };\n      } else {\n        const payload = normalizePayloadForIC(args.payload);\n        convertedArgs = {\n          options: {\n            expirationTimestamp,\n            gasUnitPrice,\n            maxGasAmount\n          },\n          payload\n        };\n      }\n      const {\n        hash\n      } = await this.pairingClient.signAndSubmitTransaction(signerAddress.toString(), convertedArgs, {\n        networkName: network\n      });\n      return makeUserApproval({\n        txnHash: hash\n      });\n    }\n    const serializedRequest = SignAndSubmitTransactionRequest.serialize(this.dappInfo, args);\n    const serializedResponse = await this.transport.sendRequest(serializedRequest);\n    const response = SignAndSubmitTransactionResponse.deserialize(serializedResponse);\n    return response.args;\n  }\n  // endregion\n};\n\n// src/ICDappClient.ts\nimport { createEd25519KeyPair as createEd25519KeyPair2, encodeBase64 as encodeBase643 } from \"@identity-connect/crypto\";\nimport { isAxiosError as isAxiosError2 } from \"axios\";\n\n// src/prompt.ts\nvar DEFAULT_PROMPT_SIZE = {\n  height: 695,\n  width: 465\n};\nvar PROMPT_POLLER_INTERVAL = 500;\nfunction openPrompt(url, size = DEFAULT_PROMPT_SIZE) {\n  const {\n    height,\n    width\n  } = size;\n  const options = {\n    height,\n    left: window.screenLeft + Math.round((window.outerWidth - width) / 2),\n    popup: true,\n    top: window.screenTop + Math.round((window.outerHeight - height) / 2),\n    width\n  };\n  const strOptions = Object.entries(options).map(([key, value]) => `${key}=${JSON.stringify(value)}`).reduce((acc, entry) => `${acc}, ${entry}`);\n  const href = url instanceof URL ? url.href : url;\n  const promptWindow = window.open(href, void 0, strOptions);\n  if (promptWindow === null) {\n    throw new Error(\"Couldn't open prompt\");\n  }\n  return promptWindow;\n}\nasync function waitForPromptResponse(promptWindow) {\n  return new Promise(resolve => {\n    const listeners = {\n      onMessage: message => {\n        if (message.source !== promptWindow) {\n          return;\n        }\n        window.removeEventListener(\"message\", listeners.onMessage);\n        clearTimeout(listeners.promptPollerId);\n        resolve({\n          args: message.data,\n          status: \"approved\"\n        });\n      },\n      promptPollerId: setInterval(() => {\n        if (promptWindow.closed) {\n          window.removeEventListener(\"message\", listeners.onMessage);\n          clearTimeout(listeners.promptPollerId);\n          resolve({\n            status: \"dismissed\"\n          });\n        }\n      }, PROMPT_POLLER_INTERVAL)\n    };\n    window.addEventListener(\"message\", listeners.onMessage);\n  });\n}\n\n// src/ICDappClient.ts\nvar ICDappClient = class extends ACPairingClient {\n  constructor(dappId, {\n    frontendBaseURL = DEFAULT_FRONTEND_URL,\n    ...pairingClientConfig\n  } = {}) {\n    super(pairingClientConfig);\n    this.dappId = dappId;\n    this.frontendBaseURL = frontendBaseURL;\n  }\n  async createPairingRequest(dappEd25519PublicKeyB64) {\n    try {\n      const response = await this.axiosInstance.post(\"v1/pairing/\", {\n        dappEd25519PublicKeyB64,\n        dappId: this.dappId\n      });\n      return response.data.data.pairing;\n    } catch (err) {\n      if (isAxiosError2(err) && err.response?.data?.message === \"Dapp not found\") {\n        throw new UnregisteredDappError();\n      }\n      throw err;\n    }\n  }\n  // region Public API\n  /**\n   * Requests a connection to an account (internally known as pairing).\n   * @returns either the address of the connected account, or undefined if the\n   * connection was cancelled.\n   */\n  async connect() {\n    const {\n      publicKey,\n      secretKey\n    } = createEd25519KeyPair2();\n    const dappEd25519PublicKeyB64 = encodeBase643(publicKey.key);\n    const url = new URL(`${this.frontendBaseURL}/pairing`);\n    const promptWindow = await openPrompt(url.href);\n    let pairingId;\n    try {\n      const pendingPairing = await this.createPairingRequest(dappEd25519PublicKeyB64);\n      pairingId = pendingPairing.id;\n    } catch (err) {\n      promptWindow.close();\n      throw err;\n    }\n    url.searchParams.set(\"pairingId\", pairingId);\n    promptWindow.location.href = url.href;\n    const promptResponse = await waitForPromptResponse(promptWindow);\n    if (promptResponse.status === \"dismissed\") {\n      void this.deletePairing(pairingId, secretKey, publicKey);\n      return void 0;\n    }\n    const finalizedPairing = promptResponse.args;\n    await this.addPairing({\n      publicKey,\n      secretKey\n    }, finalizedPairing);\n    return finalizedPairing.account.accountAddress;\n  }\n  async offboard(address) {\n    const pairing = await this.accessors.get(address);\n    if (pairing === void 0) {\n      throw new Error(\"This account is not paired\");\n    }\n    const walletId = pairing.dappWalletId;\n    if (walletId === void 0) {\n      throw new Error(\"This account cannot be offboarded\");\n    }\n    const url = new URL(`${this.frontendBaseURL}/offboarding?walletId=${walletId}`);\n    const promptWindow = openPrompt(url);\n    const response = await waitForPromptResponse(promptWindow);\n    if (response.status === \"approved\" && response.args.offboarded) {\n      this.disconnect(address);\n      return true;\n    }\n    return false;\n  }\n  // endregion\n};\n\n// src/KeylessClient.ts\nimport { ConnectRequest as ConnectRequest2, ConnectResponse as ConnectResponse2, DisconnectRequest as DisconnectRequest2, GetConnectedAccountsRequest as GetConnectedAccountsRequest2, GetConnectedAccountsResponse as GetConnectedAccountsResponse2, IsConnectedRequest, IsConnectedResponse, SignAndSubmitTransactionRequest as SignAndSubmitTransactionRequest2, SignAndSubmitTransactionResponse as SignAndSubmitTransactionResponse2, SignMessageRequest as SignMessageRequest2, SignMessageResponse as SignMessageResponse2, SignTransactionRequest as SignTransactionRequest2, SignTransactionResponse as SignTransactionResponse2 } from \"@aptos-connect/wallet-api\";\nimport { WebWalletTransport as WebWalletTransport2 } from \"@aptos-connect/web-transport\";\nimport { NetworkName as NetworkName3 } from \"@identity-connect/api\";\nvar ACKeylessClient = class {\n  constructor({\n    dappImageURI,\n    dappName,\n    defaultNetworkName = NetworkName3.MAINNET,\n    frontendBaseURL = DEFAULT_FRONTEND_URL,\n    provider = \"google\"\n  } = {}) {\n    this.defaultNetworkName = defaultNetworkName;\n    this.dappInfo = {\n      domain: window.location.origin,\n      imageURI: dappImageURI,\n      name: dappName ?? document.title\n    };\n    this.transport = new WebWalletTransport2(frontendBaseURL, provider);\n  }\n  // region Public API\n  async isConnected() {\n    const serializedRequest = IsConnectedRequest.serialize(this.dappInfo);\n    const serializedResponse = await this.transport.sendRequest(serializedRequest);\n    const response = IsConnectedResponse.deserialize(serializedResponse);\n    return response.args;\n  }\n  async getConnectedAccounts() {\n    const serializedRequest = GetConnectedAccountsRequest2.serialize(this.dappInfo);\n    const serializedResponse = await this.transport.sendRequest(serializedRequest);\n    const response = GetConnectedAccountsResponse2.deserialize(serializedResponse);\n    return response.args;\n  }\n  async disconnect() {\n    const serializedRequest = DisconnectRequest2.serialize(this.dappInfo);\n    await this.transport.sendRequest(serializedRequest);\n  }\n  async connect() {\n    const serializedRequest = ConnectRequest2.serialize(this.dappInfo);\n    const serializedResponse = await this.transport.sendRequest(serializedRequest);\n    const response = ConnectResponse2.deserialize(serializedResponse);\n    return response.args;\n  }\n  async signMessage(args) {\n    const serializedRequest = SignMessageRequest2.serialize(this.dappInfo, args);\n    const serializedResponse = await this.transport.sendRequest(serializedRequest);\n    const response = SignMessageResponse2.deserialize(serializedResponse);\n    return response.args;\n  }\n  async signTransaction(args) {\n    const normalizedArgs = \"transaction\" in args ? SignTransactionRequest2.normalizeArgs(args) : args;\n    const serializedRequest = SignTransactionRequest2.serialize(this.dappInfo, normalizedArgs);\n    const serializedResponse = await this.transport.sendRequest(serializedRequest);\n    const response = SignTransactionResponse2.deserialize(serializedResponse);\n    return response.args;\n  }\n  async signAndSubmitTransaction(args) {\n    const serializedRequest = SignAndSubmitTransactionRequest2.serialize(this.dappInfo, args);\n    const serializedResponse = await this.transport.sendRequest(serializedRequest);\n    const response = SignAndSubmitTransactionResponse2.deserialize(serializedResponse);\n    return response.args;\n  }\n  // endregion\n};\nexport { ACDappClient, ACKeylessClient, DAPP_PAIRINGS_WINDOW_STORAGE_KEY, ICDappClient, windowStateAccessors };\n//# sourceMappingURL=index.mjs.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}