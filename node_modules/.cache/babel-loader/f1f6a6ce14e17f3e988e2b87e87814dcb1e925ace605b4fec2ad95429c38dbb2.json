{"ast":null,"code":"import { a as m } from \"./chunk-5S3Z7MT4.mjs\";\nimport { a as g } from \"./chunk-YZ5BCOGI.mjs\";\nimport { c as A } from \"./chunk-BVVHGSWC.mjs\";\nimport { s as f } from \"./chunk-VHNX2NUR.mjs\";\nimport { b as w } from \"./chunk-KM6UXNC7.mjs\";\nvar T = [\"A name must be between 3 and 63 characters long,\", \"and can only contain lowercase a-z, 0-9, and hyphens.\", \"A name may not start or end with a hyphen.\"].join(\" \");\nfunction D(e) {\n  return !(!e || e.length < 3 || e.length > 63 || !/^[a-z\\d][a-z\\d-]{1,61}[a-z\\d]$/.test(e));\n}\nfunction c(e) {\n  let [t, n, ...o] = e.replace(/\\.apt$/, \"\").split(\".\");\n  if (o.length > 0) throw new Error(`${e} is invalid. A name can only have two parts, a domain and a subdomain separated by a \".\"`);\n  if (!D(t)) throw new Error(`${t} is not valid. ${T}`);\n  if (n && !D(n)) throw new Error(`${n} is not valid. ${T}`);\n  return {\n    domainName: n || t,\n    subdomainName: n ? t : void 0\n  };\n}\nvar I = (n => (n[n.Independent = 0] = \"Independent\", n[n.FollowsDomain = 1] = \"FollowsDomain\", n))(I || {});\nfunction E(e) {\n  if (!e) return !1;\n  let t = new Date(e.domain_expiration_timestamp).getTime() < Date.now(),\n    n = new Date(e.expiration_timestamp).getTime() < Date.now();\n  return e.subdomain && t ? !1 : e.subdomain && e.subdomain_expiration_policy === 1 ? !0 : !n;\n}\nvar j = \"0x37368b46ce665362562c6d1d4ec01a08c8644c488690df5a17e13ba163e20221\",\n  O = \"0x585fc9f0f0c54183b039ffc770ca282ebd87307916c215a3e692f2f8e4305e82\",\n  v = {\n    testnet: \"0x5f8fd2347449685cf41d4db97926ec3a096eaf381332be4f1318ad4d16a8497c\",\n    mainnet: \"0x867ed1f6bf916171b1de3ee92849b8978b7d1b9e0a8cc982a3d19d535dfd9c0c\",\n    local: O,\n    custom: null,\n    devnet: null\n  };\nfunction d(e) {\n  let t = v[e.network];\n  if (!t) throw new Error(`The ANS contract is not deployed to ${e.network}`);\n  return t;\n}\nvar b = e => {\n  if (e && typeof e == \"object\" && \"vec\" in e && Array.isArray(e.vec)) return e.vec[0];\n};\nasync function F(e) {\n  let {\n      aptosConfig: t,\n      name: n\n    } = e,\n    o = d(t),\n    {\n      domainName: r,\n      subdomainName: s\n    } = c(n),\n    i = await g({\n      aptosConfig: t,\n      payload: {\n        function: `${o}::router::get_owner_addr`,\n        functionArguments: [r, s]\n      }\n    }),\n    a = b(i[0]);\n  return a ? w.from(a) : void 0;\n}\nasync function Y(e) {\n  let {\n      aptosConfig: t,\n      expiration: n,\n      name: o,\n      sender: r,\n      targetAddress: s,\n      toAddress: i,\n      options: a,\n      transferable: u\n    } = e,\n    p = d(t),\n    {\n      domainName: y,\n      subdomainName: N\n    } = c(o),\n    x = n.policy === \"subdomain:independent\" || n.policy === \"subdomain:follow-domain\";\n  if (N && !x) throw new Error(\"Subdomains must have an expiration policy of either 'subdomain:independent' or 'subdomain:follow-domain'\");\n  if (x && !N) throw new Error(`Policy is set to ${n.policy} but no subdomain was provided`);\n  if (n.policy === \"domain\") {\n    let h = n.years ?? 1;\n    if (h !== 1) throw new Error(\"For now, names can only be registered for 1 year at a time\");\n    let G = h * 31536e3;\n    return await m({\n      aptosConfig: t,\n      sender: r.accountAddress.toString(),\n      data: {\n        function: `${p}::router::register_domain`,\n        functionArguments: [y, G, s, i]\n      },\n      options: a\n    });\n  }\n  if (!N) throw new Error(`${n.policy} requires a subdomain to be provided.`);\n  let _ = await P({\n    aptosConfig: t,\n    name: y\n  });\n  if (!_) throw new Error(\"The domain does not exist\");\n  let S = n.policy === \"subdomain:independent\" ? n.expirationDate : _;\n  if (S > _) throw new Error(\"The subdomain expiration time cannot be greater than the domain expiration time\");\n  return await m({\n    aptosConfig: t,\n    sender: r.accountAddress.toString(),\n    data: {\n      function: `${p}::router::register_subdomain`,\n      functionArguments: [y, N, Math.round(S / 1e3), n.policy === \"subdomain:follow-domain\" ? 1 : 0, !!u, s, i]\n    },\n    options: a\n  });\n}\nasync function P(e) {\n  let {\n      aptosConfig: t,\n      name: n\n    } = e,\n    o = d(t),\n    {\n      domainName: r,\n      subdomainName: s\n    } = c(n);\n  try {\n    let i = await g({\n      aptosConfig: t,\n      payload: {\n        function: `${o}::router::get_expiration`,\n        functionArguments: [r, s]\n      }\n    });\n    return Number(i[0]) * 1e3;\n  } catch {\n    return;\n  }\n}\nasync function K(e) {\n  let {\n      aptosConfig: t,\n      address: n\n    } = e,\n    o = d(t),\n    r = await g({\n      aptosConfig: t,\n      payload: {\n        function: `${o}::router::get_primary_name`,\n        functionArguments: [w.from(n).toString()]\n      }\n    }),\n    s = b(r[1]),\n    i = b(r[0]);\n  if (s) return [i, s].filter(Boolean).join(\".\");\n}\nasync function W(e) {\n  let {\n      aptosConfig: t,\n      sender: n,\n      name: o,\n      options: r\n    } = e,\n    s = d(t);\n  if (!o) return await m({\n    aptosConfig: t,\n    sender: n.accountAddress.toString(),\n    data: {\n      function: `${s}::router::clear_primary_name`,\n      functionArguments: []\n    },\n    options: r\n  });\n  let {\n    domainName: i,\n    subdomainName: a\n  } = c(o);\n  return await m({\n    aptosConfig: t,\n    sender: n.accountAddress.toString(),\n    data: {\n      function: `${s}::router::set_primary_name`,\n      functionArguments: [i, a]\n    },\n    options: r\n  });\n}\nasync function H(e) {\n  let {\n      aptosConfig: t,\n      name: n\n    } = e,\n    o = d(t),\n    {\n      domainName: r,\n      subdomainName: s\n    } = c(n),\n    i = await g({\n      aptosConfig: t,\n      payload: {\n        function: `${o}::router::get_target_addr`,\n        functionArguments: [r, s]\n      }\n    }),\n    a = b(i[0]);\n  return a ? w.from(a) : void 0;\n}\nasync function J(e) {\n  let {\n      aptosConfig: t,\n      sender: n,\n      name: o,\n      address: r,\n      options: s\n    } = e,\n    i = d(t),\n    {\n      domainName: a,\n      subdomainName: u\n    } = c(o);\n  return await m({\n    aptosConfig: t,\n    sender: n.accountAddress.toString(),\n    data: {\n      function: `${i}::router::set_target_addr`,\n      functionArguments: [a, u, r]\n    },\n    options: s\n  });\n}\nasync function X(e) {\n  let {\n      aptosConfig: t,\n      name: n\n    } = e,\n    {\n      domainName: o,\n      subdomainName: r = \"\"\n    } = c(n),\n    a = (await A({\n      aptosConfig: t,\n      query: {\n        query: f,\n        variables: {\n          where_condition: {\n            domain: {\n              _eq: o\n            },\n            subdomain: {\n              _eq: r\n            }\n          },\n          limit: 1\n        }\n      },\n      originMethod: \"getName\"\n    })).current_aptos_names[0];\n  return a && (a = l(a)), E(a) ? a : void 0;\n}\nasync function Z(e) {\n  let {\n      aptosConfig: t,\n      options: n,\n      accountAddress: o\n    } = e,\n    r = await C({\n      aptosConfig: t\n    });\n  return (await A({\n    aptosConfig: t,\n    originMethod: \"getAccountNames\",\n    query: {\n      query: f,\n      variables: {\n        limit: n?.limit,\n        offset: n?.offset,\n        order_by: n?.orderBy,\n        where_condition: {\n          ...(e.options?.where ?? {}),\n          owner_address: {\n            _eq: o.toString()\n          },\n          expiration_timestamp: {\n            _gte: r\n          }\n        }\n      }\n    }\n  })).current_aptos_names.map(l);\n}\nasync function ee(e) {\n  let {\n      aptosConfig: t,\n      options: n,\n      accountAddress: o\n    } = e,\n    r = await C({\n      aptosConfig: t\n    });\n  return (await A({\n    aptosConfig: t,\n    originMethod: \"getAccountDomains\",\n    query: {\n      query: f,\n      variables: {\n        limit: n?.limit,\n        offset: n?.offset,\n        order_by: n?.orderBy,\n        where_condition: {\n          ...(e.options?.where ?? {}),\n          owner_address: {\n            _eq: o.toString()\n          },\n          expiration_timestamp: {\n            _gte: r\n          },\n          subdomain: {\n            _eq: \"\"\n          }\n        }\n      }\n    }\n  })).current_aptos_names.map(l);\n}\nasync function ne(e) {\n  let {\n      aptosConfig: t,\n      options: n,\n      accountAddress: o\n    } = e,\n    r = await C({\n      aptosConfig: t\n    });\n  return (await A({\n    aptosConfig: t,\n    originMethod: \"getAccountSubdomains\",\n    query: {\n      query: f,\n      variables: {\n        limit: n?.limit,\n        offset: n?.offset,\n        order_by: n?.orderBy,\n        where_condition: {\n          ...(e.options?.where ?? {}),\n          owner_address: {\n            _eq: o.toString()\n          },\n          expiration_timestamp: {\n            _gte: r\n          },\n          subdomain: {\n            _neq: \"\"\n          }\n        }\n      }\n    }\n  })).current_aptos_names.map(l);\n}\nasync function te(e) {\n  let {\n    aptosConfig: t,\n    options: n,\n    domain: o\n  } = e;\n  return (await A({\n    aptosConfig: t,\n    originMethod: \"getDomainSubdomains\",\n    query: {\n      query: f,\n      variables: {\n        limit: n?.limit,\n        offset: n?.offset,\n        order_by: n?.orderBy,\n        where_condition: {\n          ...(e.options?.where ?? {}),\n          domain: {\n            _eq: o\n          },\n          subdomain: {\n            _neq: \"\"\n          }\n        }\n      }\n    }\n  })).current_aptos_names.map(l).filter(E);\n}\nasync function C(e) {\n  let {\n      aptosConfig: t\n    } = e,\n    n = d(t),\n    [o] = await g({\n      aptosConfig: t,\n      payload: {\n        function: `${n}::config::reregistration_grace_sec`,\n        functionArguments: []\n      }\n    }),\n    r = o / 60 / 60 / 24,\n    s = () => new Date();\n  return new Date(s().setDate(s().getDate() - r)).toISOString();\n}\nasync function oe(e) {\n  let {\n      aptosConfig: t,\n      sender: n,\n      name: o,\n      years: r = 1,\n      options: s\n    } = e,\n    i = d(t),\n    a = r * 31536e3,\n    {\n      domainName: u,\n      subdomainName: p\n    } = c(o);\n  if (p) throw new Error(\"Subdomains cannot be renewed\");\n  if (r !== 1) throw new Error(\"Currently, only 1 year renewals are supported\");\n  return await m({\n    aptosConfig: t,\n    sender: n.accountAddress.toString(),\n    data: {\n      function: `${i}::router::renew_domain`,\n      functionArguments: [u, a]\n    },\n    options: s\n  });\n}\nfunction l(e) {\n  return {\n    ...e,\n    expiration_timestamp: new Date(e.expiration_timestamp).getTime()\n  };\n}\nexport { T as a, D as b, c, I as d, E as e, j as f, O as g, F as h, Y as i, P as j, K as k, W as l, H as m, J as n, X as o, Z as p, ee as q, ne as r, te as s, oe as t };\n//# sourceMappingURL=chunk-SOLWFAUY.mjs.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}