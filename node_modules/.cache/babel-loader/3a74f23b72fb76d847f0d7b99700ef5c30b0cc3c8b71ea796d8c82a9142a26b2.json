{"ast":null,"code":"import { a } from \"./chunk-6Q2O5G3J.mjs\";\nimport { bytesToHex as s, hexToBytes as o } from \"@noble/hashes/utils\";\nvar l = (e => (e.TOO_SHORT = \"too_short\", e.INVALID_LENGTH = \"invalid_length\", e.INVALID_HEX_CHARS = \"invalid_hex_chars\", e))(l || {}),\n  i = class n {\n    constructor(t) {\n      this.data = t;\n    }\n    toUint8Array() {\n      return this.data;\n    }\n    toStringWithoutPrefix() {\n      return s(this.data);\n    }\n    toString() {\n      return `0x${this.toStringWithoutPrefix()}`;\n    }\n    static fromHexString(t) {\n      let r = t;\n      if (r.startsWith(\"0x\") && (r = r.slice(2)), r.length === 0) throw new a(\"Hex string is too short, must be at least 1 char long, excluding the optional leading 0x.\", \"too_short\");\n      if (r.length % 2 !== 0) throw new a(\"Hex string must be an even number of hex characters.\", \"invalid_length\");\n      try {\n        return new n(o(r));\n      } catch (e) {\n        throw new a(`Hex string contains invalid hex characters: ${e?.message}`, \"invalid_hex_chars\");\n      }\n    }\n    static fromHexInput(t) {\n      return t instanceof Uint8Array ? new n(t) : n.fromHexString(t);\n    }\n    static isValid(t) {\n      try {\n        return n.fromHexString(t), {\n          valid: !0\n        };\n      } catch (r) {\n        return {\n          valid: !1,\n          invalidReason: r?.invalidReason,\n          invalidReasonMessage: r?.message\n        };\n      }\n    }\n    equals(t) {\n      return this.data.length !== t.data.length ? !1 : this.data.every((r, e) => r === t.data[e]);\n    }\n  };\nexport { l as a, i as b };\n//# sourceMappingURL=chunk-KFNDDPOW.mjs.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}