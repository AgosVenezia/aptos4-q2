{"ast":null,"code":"import { a as k, b as c, d as A, e as g, f as P, g as z, h as D, i as m, j as L, l as R, m as X, n as q, o as H, p as J, q as K, s as i, t as Q } from \"./chunk-IFXUWUP2.mjs\";\nimport { c as l } from \"./chunk-KRVLR3L4.mjs\";\nimport { c as j } from \"./chunk-Y267I7DC.mjs\";\nimport { b as S, c as I, d as x, e as M, f as O, g as C, h as _, i as V, n as G } from \"./chunk-OTY3NO7Q.mjs\";\nimport { b as d } from \"./chunk-KM6UXNC7.mjs\";\nimport { a as y, c as F, d as s } from \"./chunk-IECDO22V.mjs\";\nimport { a as w, b as h, c as B, d as E, e as v, f as $, g as b } from \"./chunk-6FLHGOKP.mjs\";\nvar Y = new TextEncoder();\nfunction sn(n) {\n  return n?.map(e => c(e) ? l(e) : e) ?? [];\n}\nasync function W(n, e, t, u) {\n  let r = await j({\n    aptosConfig: u,\n    accountAddress: n,\n    moduleName: e\n  });\n  if (r.abi) return r.abi.exposed_functions.find(o => o.name === t);\n}\nasync function fn(n, e, t, u) {\n  let r = await W(n, e, t, u);\n  if (!r) throw new Error(`Could not find entry function ABI for '${n}::${e}::${t}'`);\n  if (!r.is_entry) throw new Error(`'${n}::${e}::${t}' is not an entry function`);\n  let o = Q(r),\n    T = [];\n  for (let f = o; f < r.params.length; f += 1) T.push(l(r.params[f], {\n    allowGenerics: !0\n  }));\n  return {\n    signers: o,\n    typeParameters: r.generic_type_params,\n    parameters: T\n  };\n}\nasync function on(n, e, t, u) {\n  let r = await W(n, e, t, u);\n  if (!r) throw new Error(`Could not find view function ABI for '${n}::${e}::${t}'`);\n  if (!r.is_view) throw new Error(`'${n}::${e}::${t}' is not an view function`);\n  let o = [];\n  for (let f = 0; f < r.params.length; f += 1) o.push(l(r.params[f], {\n    allowGenerics: !0\n  }));\n  let T = [];\n  for (let f = 0; f < r.return.length; f += 1) T.push(l(r.return[f], {\n    allowGenerics: !0\n  }));\n  return {\n    typeParameters: r.generic_type_params,\n    parameters: o,\n    returnTypes: T\n  };\n}\nfunction cn(n, e, t, u, r) {\n  if (u >= e.parameters.length) throw new Error(`Too many arguments for '${n}', expected ${e.parameters.length}`);\n  let o = e.parameters[u];\n  return U(t, o, u, r);\n}\nfunction U(n, e, t, u) {\n  return z(n) ? (p(e, n, t), n) : Z(n, e, t, u);\n}\nfunction Z(n, e, t, u) {\n  if (e.isBool()) {\n    if (k(n)) return new w(n);\n    if (c(n)) {\n      if (n === \"true\") return new w(!0);\n      if (n === \"false\") return new w(!1);\n    }\n    i(\"boolean\", t);\n  }\n  if (e.isAddress()) {\n    if (c(n)) return d.fromString(n);\n    i(\"string | AccountAddress\", t);\n  }\n  if (e.isU8()) {\n    let r = A(n);\n    if (r !== void 0) return new h(r);\n    i(\"number | string\", t);\n  }\n  if (e.isU16()) {\n    let r = A(n);\n    if (r !== void 0) return new B(r);\n    i(\"number | string\", t);\n  }\n  if (e.isU32()) {\n    let r = A(n);\n    if (r !== void 0) return new E(r);\n    i(\"number | string\", t);\n  }\n  if (e.isU64()) {\n    if (g(n)) return new v(BigInt(n));\n    i(\"bigint | number | string\", t);\n  }\n  if (e.isU128()) {\n    if (g(n)) return new $(BigInt(n));\n    i(\"bigint | number | string\", t);\n  }\n  if (e.isU256()) {\n    if (g(n)) return new b(BigInt(n));\n    i(\"bigint | number | string\", t);\n  }\n  if (e.isGeneric()) {\n    let r = e.value;\n    if (r < 0 || r >= u.length) throw new Error(`Generic argument ${e.toString()} is invalid for argument ${t}`);\n    return U(n, u[r], t, u);\n  }\n  if (e.isVector()) {\n    if (e.value.isU8()) {\n      if (c(n)) return y.U8(Y.encode(n));\n      if (n instanceof Uint8Array) return y.U8(n);\n      if (n instanceof ArrayBuffer) return y.U8(new Uint8Array(n));\n    }\n    if (Array.isArray(n)) return new y(n.map(r => U(r, e.value, t, u)));\n    throw new Error(`Type mismatch for argument ${t}, type '${e.toString()}'`);\n  }\n  if (e.isStruct()) {\n    if (e.isString()) {\n      if (c(n)) return new F(n);\n      i(\"string\", t);\n    }\n    if (e.isObject()) {\n      if (c(n)) return d.fromString(n);\n      i(\"string | AccountAddress\", t);\n    }\n    if (e.isOption()) {\n      if (P(n)) {\n        let r = e.value.typeArgs[0];\n        return r instanceof S ? new s(null) : r instanceof V ? new s(null) : r instanceof I ? new s(null) : r instanceof x ? new s(null) : r instanceof M ? new s(null) : r instanceof O ? new s(null) : r instanceof C ? new s(null) : r instanceof _ ? new s(null) : new s(null);\n      }\n      return new s(U(n, e.value.typeArgs[0], t, u));\n    }\n    throw new Error(`Unsupported struct input type for argument ${t}, type '${e.toString()}'`);\n  }\n  throw new Error(`Type mismatch for argument ${t}, type '${e.toString()}'`);\n}\nfunction p(n, e, t) {\n  if (n.isBool()) {\n    if (D(e)) return;\n    i(\"Bool\", t);\n  }\n  if (n.isAddress()) {\n    if (m(e)) return;\n    i(\"AccountAddress\", t);\n  }\n  if (n.isU8()) {\n    if (R(e)) return;\n    i(\"U8\", t);\n  }\n  if (n.isU16()) {\n    if (X(e)) return;\n    i(\"U16\", t);\n  }\n  if (n.isU32()) {\n    if (q(e)) return;\n    i(\"U32\", t);\n  }\n  if (n.isU64()) {\n    if (H(e)) return;\n    i(\"U64\", t);\n  }\n  if (n.isU128()) {\n    if (J(e)) return;\n    i(\"U128\", t);\n  }\n  if (n.isU256()) {\n    if (K(e)) return;\n    i(\"U256\", t);\n  }\n  if (n.isVector()) {\n    if (e instanceof y) {\n      e.values.length > 0 && p(n.value, e.values[0], t);\n      return;\n    }\n    i(\"MoveVector\", t);\n  }\n  if (n instanceof G) {\n    if (n.isString()) {\n      if (L(e)) return;\n      i(\"MoveString\", t);\n    }\n    if (n.isObject()) {\n      if (m(e)) return;\n      i(\"AccountAddress\", t);\n    }\n    if (n.isOption()) {\n      if (e instanceof s) {\n        e.value !== void 0 && p(n.value.typeArgs[0], e.value, t);\n        return;\n      }\n      i(\"MoveOption\", t);\n    }\n  }\n  throw new Error(`Type mismatch for argument ${t}, expected '${n.toString()}'`);\n}\nexport { sn as a, W as b, fn as c, on as d, cn as e, U as f };\n//# sourceMappingURL=chunk-DMSHPWA5.mjs.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}