{"ast":null,"code":"import { a as y } from \"./chunk-CDQGPCHU.mjs\";\nimport { a as u } from \"./chunk-WV2VJQDS.mjs\";\nimport { i as c, n as d } from \"./chunk-FTZGP6XW.mjs\";\nimport { a as p } from \"./chunk-N47FTRYO.mjs\";\nimport { jwtDecode as h } from \"jwt-decode\";\nvar f = class i extends y {\n  constructor(e) {\n    let r = c.create(e);\n    super({\n      publicKey: r,\n      ...e\n    }), this.publicKey = r;\n  }\n  serialize(e) {\n    if (e.serializeStr(this.jwt), e.serializeStr(this.uidKey), e.serializeFixedBytes(this.pepper), this.ephemeralKeyPair.serialize(e), this.proof === void 0) throw new Error(\"Cannot serialize - proof undefined\");\n    this.proof.serialize(e);\n  }\n  static deserialize(e) {\n    let r = e.deserializeStr(),\n      s = e.deserializeStr(),\n      o = e.deserializeFixedBytes(31),\n      a = u.deserialize(e),\n      n = d.deserialize(e);\n    return i.create({\n      proof: n,\n      pepper: o,\n      uidKey: s,\n      jwt: r,\n      ephemeralKeyPair: a\n    });\n  }\n  static fromBytes(e) {\n    return i.deserialize(new p(e));\n  }\n  static create(e) {\n    let {\n        address: r,\n        proof: s,\n        jwt: o,\n        ephemeralKeyPair: a,\n        pepper: n,\n        uidKey: l = \"sub\",\n        proofFetchCallback: K\n      } = e,\n      t = h(o);\n    if (typeof t.iss != \"string\") throw new Error(\"iss was not found\");\n    if (typeof t.aud != \"string\") throw new Error(\"aud was not found or an array of values\");\n    let m = t[l];\n    return new i({\n      address: r,\n      proof: s,\n      ephemeralKeyPair: a,\n      iss: t.iss,\n      uidKey: l,\n      uidVal: m,\n      aud: t.aud,\n      pepper: n,\n      jwt: o,\n      proofFetchCallback: K\n    });\n  }\n};\nexport { f as a };\n//# sourceMappingURL=chunk-M22UGFQ5.mjs.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}