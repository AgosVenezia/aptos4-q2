{"ast":null,"code":"import { a as K, b as w } from \"./chunk-WSZCPSV4.mjs\";\nimport { d as h } from \"./chunk-MK2QAHXC.mjs\";\nimport { a, b as c } from \"./chunk-TPJLAYW6.mjs\";\nimport { j as m, k as g, n as P } from \"./chunk-FTZGP6XW.mjs\";\nimport { b as d } from \"./chunk-KM6UXNC7.mjs\";\nimport { a as n } from \"./chunk-QQIVWB6G.mjs\";\nimport { b as f } from \"./chunk-KFNDDPOW.mjs\";\nimport { d as y } from \"./chunk-LEKBJ2EG.mjs\";\nimport v from \"eventemitter3\";\nvar o = class o extends n {\n  constructor(e) {\n    super();\n    let {\n      address: r,\n      ephemeralKeyPair: t,\n      publicKey: i,\n      uidKey: F,\n      uidVal: b,\n      aud: E,\n      pepper: A,\n      proof: s,\n      proofFetchCallback: l,\n      jwt: x\n    } = e;\n    if (this.ephemeralKeyPair = t, this.publicKey = i, this.accountAddress = r ? d.from(r) : this.publicKey.authKey().derivedAddress(), this.uidKey = F, this.uidVal = b, this.aud = E, this.jwt = x, this.emitter = new v(), this.proofOrPromise = s, s instanceof P) this.proof = s;else {\n      if (l === void 0) throw new Error(\"Must provide callback for async proof fetch\");\n      this.emitter.on(\"proofFetchFinish\", async T => {\n        await l(T), this.emitter.removeAllListeners();\n      }), this.init(s);\n    }\n    this.signingScheme = 2;\n    let u = f.fromHexInput(A).toUint8Array();\n    if (u.length !== o.PEPPER_LENGTH) throw new Error(`Pepper length in bytes should be ${o.PEPPER_LENGTH}`);\n    this.pepper = u;\n  }\n  async init(e) {\n    try {\n      this.proof = await e, this.emitter.emit(\"proofFetchFinish\", {\n        status: \"Success\"\n      });\n    } catch (r) {\n      r instanceof Error ? this.emitter.emit(\"proofFetchFinish\", {\n        status: \"Failed\",\n        error: r.toString()\n      }) : this.emitter.emit(\"proofFetchFinish\", {\n        status: \"Failed\",\n        error: \"Unknown\"\n      });\n    }\n  }\n  serialize(e) {\n    if (e.serializeStr(this.jwt), e.serializeStr(this.uidKey), e.serializeFixedBytes(this.pepper), this.ephemeralKeyPair.serialize(e), this.proof === void 0) throw new Error(\"Cannot serialize - proof undefined\");\n    this.proof.serialize(e);\n  }\n  isExpired() {\n    return this.ephemeralKeyPair.isExpired();\n  }\n  signWithAuthenticator(e) {\n    let r = new c(this.sign(e)),\n      t = new a(this.publicKey);\n    return new h(t, r);\n  }\n  signTransactionWithAuthenticator(e) {\n    let r = new c(this.signTransaction(e)),\n      t = new a(this.publicKey);\n    return new h(t, r);\n  }\n  async waitForProofFetch() {\n    this.proofOrPromise instanceof Promise && (await this.proofOrPromise);\n  }\n  sign(e) {\n    let {\n      expiryDateSecs: r\n    } = this.ephemeralKeyPair;\n    if (this.isExpired()) throw new Error(\"EphemeralKeyPair is expired\");\n    if (this.proof === void 0) throw new Error(\"Proof not found - make sure to call `await account.waitForProofFetch()` before signing.\");\n    let t = this.ephemeralKeyPair.getPublicKey(),\n      i = this.ephemeralKeyPair.sign(e);\n    return new m({\n      jwtHeader: y(this.jwt.split(\".\")[0]),\n      ephemeralCertificate: new g(this.proof, 0),\n      expiryDateSecs: r,\n      ephemeralPublicKey: t,\n      ephemeralSignature: i\n    });\n  }\n  signTransaction(e) {\n    if (this.proof === void 0) throw new Error(\"Proof not found - make sure to call `await account.waitForProofFetch()` before signing.\");\n    let r = K(e),\n      i = new p(r, this.proof.proof).hash();\n    return this.sign(i);\n  }\n  verifySignature(e) {\n    let {\n      message: r,\n      signature: t\n    } = e;\n    return !(this.isExpired() || !this.ephemeralKeyPair.getPublicKey().verifySignature({\n      message: r,\n      signature: t.ephemeralSignature\n    }));\n  }\n};\no.PEPPER_LENGTH = 31;\nvar S = o,\n  p = class extends n {\n    constructor(r, t) {\n      super();\n      this.domainSeparator = \"APTOS::TransactionAndProof\";\n      this.transaction = r, this.proof = t;\n    }\n    serialize(r) {\n      r.serializeFixedBytes(this.transaction.bcsToBytes()), r.serializeOption(this.proof);\n    }\n    hash() {\n      return w(this.bcsToBytes(), this.domainSeparator);\n    }\n  };\nexport { S as a, p as b };\n//# sourceMappingURL=chunk-CDQGPCHU.mjs.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}