{"ast":null,"code":"export const uppercase = str => str.toUpperCase();\nexport const callOrIdentity = value => {\n  return typeof value === `function` ? value() : value;\n};\nexport const zip = (a, b) => a.map((k, i) => [k, b[i]]);\nexport const HeadersInitToPlainObject = headers => {\n  let oHeaders = {};\n  if (headers instanceof Headers) {\n    oHeaders = HeadersInstanceToPlainObject(headers);\n  } else if (Array.isArray(headers)) {\n    headers.forEach(([name, value]) => {\n      if (name && value !== undefined) {\n        oHeaders[name] = value;\n      }\n    });\n  } else if (headers) {\n    oHeaders = headers;\n  }\n  return oHeaders;\n};\nexport const HeadersInstanceToPlainObject = headers => {\n  const o = {};\n  headers.forEach((v, k) => {\n    o[k] = v;\n  });\n  return o;\n};\nexport const tryCatch = fn => {\n  try {\n    const result = fn();\n    if (isPromiseLikeValue(result)) {\n      return result.catch(error => {\n        return errorFromMaybeError(error);\n      });\n    }\n    return result;\n  } catch (error) {\n    return errorFromMaybeError(error);\n  }\n};\n/**\n * Ensure that the given value is an error and return it. If it is not an error than\n * wrap it in one, passing the given value as the error message.\n */\nexport const errorFromMaybeError = maybeError => {\n  if (maybeError instanceof Error) return maybeError;\n  return new Error(String(maybeError));\n};\nexport const isPromiseLikeValue = value => {\n  return typeof value === `object` && value !== null && `then` in value && typeof value.then === `function` && `catch` in value && typeof value.catch === `function` && `finally` in value && typeof value.finally === `function`;\n};\nexport const casesExhausted = value => {\n  throw new Error(`Unhandled case: ${String(value)}`);\n};\nexport const isPlainObject = value => {\n  return typeof value === `object` && value !== null && !Array.isArray(value);\n};\nexport const entries = obj => Object.entries(obj);\nexport const values = obj => Object.values(obj);\nexport const mapValues = (object, fn) => {\n  return Object.fromEntries(Object.entries(object).map(([key, value]) => {\n    return [key, fn(value, key)];\n  }));\n};\nexport const lowerCaseFirstLetter = s => {\n  return s.charAt(0).toLowerCase() + s.slice(1);\n};\nexport function assertArray(v) {\n  if (!Array.isArray(v)) throw new Error(`Expected array. Got: ${String(v)}`);\n}\nexport function assertObject(v) {\n  if (v === null || typeof v !== `object`) throw new Error(`Expected object. Got: ${String(v)}`);\n}\nexport const capitalizeFirstLetter = string => string.charAt(0).toUpperCase() + string.slice(1);\nexport const createDeferred = options => {\n  let isResolved = false;\n  let resolve;\n  let reject;\n  const promise = new Promise(($resolve, $reject) => {\n    resolve = $resolve;\n    reject = $reject;\n  });\n  return {\n    promise,\n    isResolved: () => isResolved,\n    resolve: value => {\n      isResolved = true;\n      if (options?.strict && isResolved) {\n        throw new Error(`Deferred is already resolved. Attempted to resolve with: ${JSON.stringify(value)}`);\n      }\n      resolve(value);\n    },\n    reject: error => reject(error)\n  };\n};\nexport const debug = (...args) => {\n  if (process.env[`DEBUG`]) {\n    console.log(...args);\n  }\n};\nexport const debugSub = (...args) => (...subArgs) => {\n  debug(...args, ...subArgs);\n};\nexport const partitionErrors = array => {\n  const errors = [];\n  const values = [];\n  for (const item of array) {\n    if (item instanceof Error) {\n      errors.push(item);\n    } else {\n      values.push(item);\n    }\n  }\n  return [values, errors];\n};\n//# sourceMappingURL=prelude.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}